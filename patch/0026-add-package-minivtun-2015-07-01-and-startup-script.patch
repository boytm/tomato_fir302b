From 8c1d1629b63a3067395a14e122e3074ed7945bd0 Mon Sep 17 00:00:00 2001
From: Jesse <boycht@gmail.com>
Date: Sun, 9 Aug 2015 20:55:33 +0800
Subject: [PATCH 26/26] add package minivtun (2015-07-01) and startup script

---
 release/src/Makefile                       |  11 +-
 release/src/router/Makefile                |  16 +
 release/src/router/config/config.in        |   4 +
 release/src/router/config_base             |   1 +
 release/src/router/dnsmasq/src/network.c   |   2 +-
 release/src/router/libcurl/Makefile        | 365 ---------------
 release/src/router/minivtun/README.md      |  62 +++
 release/src/router/minivtun/src/Makefile   |  35 ++
 release/src/router/minivtun/src/client.c   | 297 ++++++++++++
 release/src/router/minivtun/src/jhash.h    | 130 ++++++
 release/src/router/minivtun/src/library.c  |  83 ++++
 release/src/router/minivtun/src/library.h  | 152 ++++++
 release/src/router/minivtun/src/list.h     | 192 ++++++++
 release/src/router/minivtun/src/minivtun.c | 296 ++++++++++++
 release/src/router/minivtun/src/minivtun.h |  84 ++++
 release/src/router/minivtun/src/server.c   | 713 +++++++++++++++++++++++++++++
 release/src/router/rc/Makefile             |   4 +
 release/src/router/rc/minivtun.c           |  20 +
 release/src/router/rc/rc.h                 |   6 +
 release/src/router/rc/services.c           |   8 +
 release/src/router/rc/wan.c                |   5 +
 release/src/router/rom/rom/etc/minivtun.sh |  63 +++
 release/src/router/shared/tomato_version   |   2 +-
 release/src/router/zlib/Makefile           |   5 -
 release/src/router/zlib/zconf.h            | 511 ---------------------
 25 files changed, 2183 insertions(+), 884 deletions(-)
 delete mode 100644 release/src/router/libcurl/Makefile
 create mode 100644 release/src/router/minivtun/README.md
 create mode 100644 release/src/router/minivtun/src/Makefile
 create mode 100644 release/src/router/minivtun/src/client.c
 create mode 100644 release/src/router/minivtun/src/jhash.h
 create mode 100644 release/src/router/minivtun/src/library.c
 create mode 100644 release/src/router/minivtun/src/library.h
 create mode 100644 release/src/router/minivtun/src/list.h
 create mode 100644 release/src/router/minivtun/src/minivtun.c
 create mode 100644 release/src/router/minivtun/src/minivtun.h
 create mode 100644 release/src/router/minivtun/src/server.c
 create mode 100644 release/src/router/rc/minivtun.c
 create mode 100755 release/src/router/rom/rom/etc/minivtun.sh
 delete mode 100644 release/src/router/zlib/Makefile
 delete mode 100644 release/src/router/zlib/zconf.h

diff --git a/release/src/Makefile b/release/src/Makefile
index b01a9f3..25d1eed 100644
--- a/release/src/Makefile
+++ b/release/src/Makefile
@@ -50,6 +50,7 @@ ND = "ND"
 endif
 
 PPTPD ?= "n"
+MINIVTUN ?= "n"
 
 ifeq ($(NVRAM_SIZE),)
 NVRAM_SIZE = 0
@@ -476,6 +477,10 @@ define RouterOptions
 		sed -i "/TCONFIG_PPTPD/d" $(1); \
 		echo "TCONFIG_PPTPD=y" >>$(1); \
 	fi; \
+	if [ "$(MINIVTUN)" = "y" ]; then \
+		sed -i "/TCONFIG_MINIVTUN/d" $(1); \
+		echo "TCONFIG_MINIVTUN=y" >>$(1); \
+	fi; \
 	if [ "$(BTCLIENT)" = "y" ]; then \
 		sed -i "/TCONFIG_BT/d" $(1); \
 		echo "TCONFIG_BT=y" >>$(1); \
@@ -755,6 +760,10 @@ define KernelConfig
 		sed -i "/CONFIG_EFI_PARTITION/d" $(1); \
 		echo "# CONFIG_EFI_PARTITION is not set" >>$(1); \
 	fi; \
+	if [ "$(MINIVTUN)" = "y" ]; then \
+		sed -i "/CONFIG_TUN/d" $(1); \
+		echo "CONFIG_TUN=y" >>$(1); \
+	fi; \
 	if [ "$(IPV6SUPP)" = "y" ]; then \
 		sed -i "/CONFIG_IPV6 is not set/d" $(1); \
 		echo "CONFIG_IPV6=y" >>$(1); \
@@ -1140,7 +1149,7 @@ e3200:
 	@$(MAKE) r2z USBAP=y NVRAM_SIZE=60 LINKSYS_E3200=y
 
 fir302b:
-	@$(MAKE) bin MIPS32=r2 NO_JFFS=y NO_CIFS=y NO_ZEBRA=y B=V BUILD_DESC="Fir302B_MiniVPN" USB="" PPTPD=y OPENVPN=n NO_HTTPS=y NO_XXTP=n
+	@$(MAKE) bin MIPS32=r2 NO_JFFS=y NO_CIFS=y NO_ZEBRA=y B=V BUILD_DESC="Fir302B_MiniVPN" USB="" PPTPD=y OPENVPN=n NO_HTTPS=y NO_XXTP=n MINIVTUN=y
 
 n6:
 	@$(MAKE) bin MIPS32=r2 OPENVPN=y BBEXTRAS=y EBTABLES=y IPV6SUPP=y B=E BUILD_DESC="TendaN6" USB="USB" TOR=y NOCAT=y DNSCRYPT=y PPTPD=y USBAP=y NO_USBAPP=y
diff --git a/release/src/router/Makefile b/release/src/router/Makefile
index 1bb8c78..b039ac5 100644
--- a/release/src/router/Makefile
+++ b/release/src/router/Makefile
@@ -177,6 +177,7 @@ obj-$(CONFIG_LINUX26) += ipset
 obj-$(TCONFIG_L2TP) += xl2tpd
 obj-$(TCONFIG_PPTP) += accel-pptp
 obj-$(TCONFIG_PPTPD) += pptpd
+obj-$(TCONFIG_MINIVTUN) += minivtun
 obj-$(TCONFIG_HTTPS) += openssl
 obj-$(TCONFIG_SSH) += dropbear
 obj-$(TCONFIG_ZEBRA) += zebra
@@ -1856,6 +1857,21 @@ lzo-install: lzo
 	$(STRIP) $(INSTALLDIR)/lzo/usr/lib/liblzo2.so.2
 	cd $(INSTALLDIR)/lzo/usr/lib && ln -sf liblzo2.so.2 liblzo2.so
 
+minivtun/stamp-h1:
+	#cd minivtun && \
+	touch minivtun/stamp-h1
+
+minivtun: minivtun/stamp-h1 minivtun/src/minivtun $(if $(FULL_OPENSSL),openssl,cyassl)
+	@$(MAKE) -C minivtun/src $(PARALLEL_BUILD)
+
+minivtun-clean:
+	-@$(MAKE) -C minivtun clean
+	@rm -f minivtun/stamp-h1
+
+minivtun-install: minivtun
+	install -D minivtun/src/minivtun $(INSTALLDIR)/minivtun/usr/sbin/minivtun
+	$(STRIP) $(INSTALLDIR)/minivtun/usr/sbin/minivtun
+
 openvpn/.conf: openssl lzo
 	cd openvpn && CFLAGS="-O3 -Wall $(EXTRACFLAGS) -ffunction-sections -fdata-sections" \
 	LDFLAGS="-L$(TOP)/openssl -L$(TOP)/lzo/src/.libs -ffunction-sections -fdata-sections -Wl,--gc-sections" \
diff --git a/release/src/router/config/config.in b/release/src/router/config/config.in
index 6b29d50..5c66f89 100644
--- a/release/src/router/config/config.in
+++ b/release/src/router/config/config.in
@@ -209,3 +209,7 @@ config TCONFIG_UFSD
 config TCONFIG_DNSSEC
 	bool "DNSSEC"
 	default n
+
+config TCONFIG_MINIVTUN
+	bool "minivtun client"
+	default n
diff --git a/release/src/router/config_base b/release/src/router/config_base
index 126a905..a81f78e 100644
--- a/release/src/router/config_base
+++ b/release/src/router/config_base
@@ -47,3 +47,4 @@ TCONFIG_SAMBASRV=y
 # TCONFIG_CTF is not set
 # TCONFIG_UFSD is not set
 # TCONFIG_DNSSEC is not set
+# TCONFIG_MINIVTUN is not set
diff --git a/release/src/router/dnsmasq/src/network.c b/release/src/router/dnsmasq/src/network.c
index 3db7c43..b7d66c7 100644
--- a/release/src/router/dnsmasq/src/network.c
+++ b/release/src/router/dnsmasq/src/network.c
@@ -1472,7 +1472,7 @@ void check_servers(void)
 	  else if (serv->interface[0] != 0)
 	    my_syslog(LOG_INFO, _("using nameserver %s#%d(via %s)"), daemon->namebuff, port, serv->interface); 
 	  else
-	    my_syslog(LOG_INFO, _("using nameserver %s#%d"), daemon->namebuff, port); 
+	    /*my_syslog(LOG_INFO, _("using nameserver %s#%d"), daemon->namebuff, port)*/; 
 	}
     }
 
diff --git a/release/src/router/libcurl/Makefile b/release/src/router/libcurl/Makefile
deleted file mode 100644
index 343b40c..0000000
--- a/release/src/router/libcurl/Makefile
+++ /dev/null
@@ -1,365 +0,0 @@
-#***************************************************************************
-#                                  _   _ ____  _
-#  Project                     ___| | | |  _ \| |
-#                             / __| | | | |_) | |
-#                            | (__| |_| |  _ <| |___
-#                             \___|\___/|_| \_\_____|
-#
-# Copyright (C) 1998 - 2014, Daniel Stenberg, <daniel@haxx.se>, et al.
-#
-# This software is licensed as described in the file COPYING, which
-# you should have received as part of this distribution. The terms
-# are also available at http://curl.haxx.se/docs/copyright.html.
-#
-# You may opt to use, copy, modify, merge, publish, distribute and/or sell
-# copies of the Software, and permit persons to whom the Software is
-# furnished to do so, under the terms of the COPYING file.
-#
-# This software is distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY
-# KIND, either express or implied.
-#
-###########################################################################
-
-VC=vc6
-
-all:
-	./configure
-	make
-
-ssl:
-	./configure --with-ssl
-	make
-
-borland:
-	cd lib
-	$(MAKE) -f Makefile.b32
-	cd ..\src
-	$(MAKE) -f Makefile.b32
-
-borland-ssl:
-	cd lib
-	$(MAKE) -f Makefile.b32 WITH_SSL=1
-	cd ..\src
-	$(MAKE) -f Makefile.b32 WITH_SSL=1
-
-borland-ssl-zlib:
-	cd lib
-	$(MAKE) -f Makefile.b32 WITH_SSL=1 WITH_ZLIB=1
-	cd ..\src
-	$(MAKE) -f Makefile.b32 WITH_SSL=1 WITH_ZLIB=1
-
-borland-clean:
-	cd lib
-	$(MAKE) -f Makefile.b32 clean
-	cd ..\src
-	$(MAKE) -f Makefile.b32 clean
-
-watcom: .SYMBOLIC
-	cd lib && $(MAKE) -u -f Makefile.Watcom
-	cd src && $(MAKE) -u -f Makefile.Watcom
-
-watcom-clean: .SYMBOLIC
-	cd lib && $(MAKE) -u -f Makefile.Watcom clean
-	cd src && $(MAKE) -u -f Makefile.Watcom clean
-
-watcom-vclean: .SYMBOLIC
-	cd lib && $(MAKE) -u -f Makefile.Watcom vclean
-	cd src && $(MAKE) -u -f Makefile.Watcom vclean
-
-mingw32:
-	$(MAKE) -C lib -f Makefile.m32
-	$(MAKE) -C src -f Makefile.m32
-
-mingw32-clean:
-	$(MAKE) -C lib -f Makefile.m32 clean
-	$(MAKE) -C src -f Makefile.m32 clean
-	$(MAKE) -C docs/examples -f Makefile.m32 clean
-
-mingw32-vclean mingw32-distclean:
-	$(MAKE) -C lib -f Makefile.m32 vclean
-	$(MAKE) -C src -f Makefile.m32 vclean
-	$(MAKE) -C docs/examples -f Makefile.m32 vclean
-
-mingw32-examples%:
-	$(MAKE) -C docs/examples -f Makefile.m32 CFG=$@
-
-mingw32%:
-	$(MAKE) -C lib -f Makefile.m32 CFG=$@
-	$(MAKE) -C src -f Makefile.m32 CFG=$@
-
-vc-clean: $(VC)
-	cd lib
-	nmake -f Makefile.$(VC) clean
-	cd ..\src
-	nmake -f Makefile.$(VC) clean
-
-vc-all: $(VC)
-	cd lib
-	nmake -f Makefile.$(VC) cfg=release
-	nmake -f Makefile.$(VC) cfg=release-ssl
-	nmake -f Makefile.$(VC) cfg=release-zlib
-	nmake -f Makefile.$(VC) cfg=release-ssl-zlib
-	nmake -f Makefile.$(VC) cfg=release-ssl-dll
-	nmake -f Makefile.$(VC) cfg=release-zlib-dll
-	nmake -f Makefile.$(VC) cfg=release-ssl-dll-zlib-dll
-	nmake -f Makefile.$(VC) cfg=release-dll
-	nmake -f Makefile.$(VC) cfg=release-dll-ssl-dll
-	nmake -f Makefile.$(VC) cfg=release-dll-zlib-dll
-	nmake -f Makefile.$(VC) cfg=release-dll-ssl-dll-zlib-dll
-	nmake -f Makefile.$(VC) cfg=debug
-	nmake -f Makefile.$(VC) cfg=debug-ssl
-	nmake -f Makefile.$(VC) cfg=debug-zlib
-	nmake -f Makefile.$(VC) cfg=debug-ssl-zlib
-	nmake -f Makefile.$(VC) cfg=debug-ssl-dll
-	nmake -f Makefile.$(VC) cfg=debug-zlib-dll
-	nmake -f Makefile.$(VC) cfg=debug-ssl-dll-zlib-dll
-	nmake -f Makefile.$(VC) cfg=debug-dll
-	nmake -f Makefile.$(VC) cfg=debug-dll-ssl-dll
-	nmake -f Makefile.$(VC) cfg=debug-dll-zlib-dll
-	nmake -f Makefile.$(VC) cfg=debug-dll-ssl-dll-zlib-dll
-
-vc: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release
-	cd ..\src
-	nmake /f Makefile.$(VC)
-
-vc-x64: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release
-
-vc-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-zlib
-
-vc-x64-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-zlib
-
-vc-ssl: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-ssl
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-ssl
-
-vc-winssl: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-winssl WINDOWS_SSPI=1
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-winssl WINDOWS_SSPI=1
-
-vc-x64-ssl: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-ssl
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-ssl
-
-vc-x64-winssl: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-winssl WINDOWS_SSPI=1
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-winssl WINDOWS_SSPI=1
-
-vc-ssl-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-ssl-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-ssl-zlib
-
-vc-winssl-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-winssl-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-winssl-zlib
-
-vc-x64-ssl-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-ssl-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-ssl-zlib
-
-vc-x64-winssl-zlib: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-winssl-zlib
-	cd ..\src
-	nmake /f Makefile.$(VC) MACHINE=x64 cfg=release-winssl-zlib
-
-vc-ssl-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-ssl-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-ssl-dll
-
-vc-dll-ssl-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-dll-ssl-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-dll-ssl-dll
-
-vc-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-dll
-
-vc-dll-zlib-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-dll-zlib-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-dll-zlib-dll
-
-vc-dll-ssl-dll-zlib-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-dll-ssl-dll-zlib-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-dll-ssl-dll-zlib-dll
-
-vc-ssl-dll-zlib-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-ssl-dll-zlib-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-ssl-dll-zlib-dll
-
-vc-zlib-dll: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release-zlib-dll
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release-zlib-dll
-
-vc-sspi: $(VC)
-	cd lib
-	nmake /f Makefile.$(VC) cfg=release WINDOWS_SSPI=1
-	cd ..\src
-	nmake /f Makefile.$(VC) cfg=release WINDOWS_SSPI=1
-
-djgpp:
-	$(MAKE) -C lib -f Makefile.dj
-	$(MAKE) -C src -f Makefile.dj
-
-cygwin:
-	./configure
-	make
-
-cygwin-ssl:
-	./configure --with-ssl
-	make
-
-amiga:
-	cd ./lib && make -f makefile.amiga
-	cd ./src && make -f makefile.amiga
-
-netware:
-	$(MAKE) -C lib -f Makefile.netware
-	$(MAKE) -C src -f Makefile.netware
-
-netware-clean:
-	$(MAKE) -C lib -f Makefile.netware clean
-	$(MAKE) -C src -f Makefile.netware clean
-	$(MAKE) -C docs/examples -f Makefile.netware clean
-
-netware-vclean netware-distclean:
-	$(MAKE) -C lib -f Makefile.netware vclean
-	$(MAKE) -C src -f Makefile.netware vclean
-	$(MAKE) -C docs/examples -f Makefile.netware vclean
-
-netware-install:
-	$(MAKE) -C lib -f Makefile.netware install
-	$(MAKE) -C src -f Makefile.netware install
-
-netware-examples-%:
-	$(MAKE) -C docs/examples -f Makefile.netware CFG=$@
-
-netware-%:
-	$(MAKE) -C lib -f Makefile.netware CFG=$@
-	$(MAKE) -C src -f Makefile.netware CFG=$@
-
-unix: all
-
-unix-ssl: ssl
-
-linux: all
-
-linux-ssl: ssl
-
-# We don't need to do anything for vc6.
-vc6:
-
-# VC7 makefiles are for use with VS.NET and VS.NET 2003
-vc7: lib/Makefile.vc7 src/Makefile.vc7
-
-lib/Makefile.vc7: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s/VC6/VC7/g" lib/Makefile.vc6 > lib/Makefile.vc7
-
-src/Makefile.vc7: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s/VC6/VC7/g" src/Makefile.vc6 > src/Makefile.vc7
-
-# VC8 makefiles are for use with VS2005
-vc8: lib/Makefile.vc8 src/Makefile.vc8
-
-lib/Makefile.vc8: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib bufferoverflowu.lib/g" -e "s/VC6/VC8/g" lib/Makefile.vc6 > lib/Makefile.vc8
-
-src/Makefile.vc8: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib bufferoverflowu.lib/g" -e "s/VC6/VC8/g" src/Makefile.vc6 > src/Makefile.vc8
-
-# VC9 makefiles are for use with VS2008
-vc9: lib/Makefile.vc9 src/Makefile.vc9
-
-lib/Makefile.vc9: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc9/g" -e "s/VC6/VC9/g" lib/Makefile.vc6 > lib/Makefile.vc9
-
-src/Makefile.vc9: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc9/g" -e "s/VC6/VC9/g" src/Makefile.vc6 > src/Makefile.vc9
-
-# VC10 makefiles are for use with VS2010
-vc10: lib/Makefile.vc10 src/Makefile.vc10
-
-lib/Makefile.vc10: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc10/g" -e "s/VC6/VC10/g" lib/Makefile.vc6 > lib/Makefile.vc10
-
-src/Makefile.vc10: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc10/g" -e "s/VC6/VC10/g" src/Makefile.vc6 > src/Makefile.vc10
-
-# VC11 makefiles are for use with VS2012
-vc11: lib/Makefile.vc11 src/Makefile.vc11
-
-lib/Makefile.vc11: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc11/g" -e "s/VC6/VC11/g" lib/Makefile.vc6 > lib/Makefile.vc11
-
-src/Makefile.vc11: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc11/g" -e "s/VC6/VC11/g" src/Makefile.vc6 > src/Makefile.vc11
-
-# VC12 makefiles are for use with VS2013
-vc12: lib/Makefile.vc12 src/Makefile.vc12
-
-lib/Makefile.vc12: lib/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc12/g" -e "s/VC6/VC12/g" lib/Makefile.vc6 > lib/Makefile.vc12
-
-src/Makefile.vc12: src/Makefile.vc6
-	@echo "generate $@"
-	@sed -e "s#/GX /DWIN32 /YX#/EHsc /DWIN32#" -e "s#/GZ#/RTC1#" -e "s/ws2_32.lib/ws2_32.lib/g" -e "s/vc6/vc12/g" -e "s/VC6/VC12/g" src/Makefile.vc6 > src/Makefile.vc12
-
-ca-bundle: lib/mk-ca-bundle.pl
-	@echo "generate a fresh ca-bundle.crt"
-	@perl $< -b -l -u lib/ca-bundle.crt
-
-ca-firefox: lib/firefox-db2pem.sh
-	@echo "generate a fresh ca-bundle.crt"
-	./lib/firefox-db2pem.sh lib/ca-bundle.crt
diff --git a/release/src/router/minivtun/README.md b/release/src/router/minivtun/README.md
new file mode 100644
index 0000000..b6e7aec
--- /dev/null
+++ b/release/src/router/minivtun/README.md
@@ -0,0 +1,62 @@
+# minivtun
+A fast secure and reliable VPN service in non-standard protocol for rapidly deploying VPN servers/clients or getting through firewalls
+
+### Key features
+* Fast: direct UDP-encapsulated without complex authentication handshakes.
+* Secure: both header and tunnel data are encrypted, which is impossible to be tracked by protocol characteristics and blocked, unless all UDP ports are blocked by your firewall; spoofed packets from unauthorized peer are dropped immediately.
+* Reliable: communication recovers immediately from next received packet from client after the previous session was dead, which makes the connection extremely reliable.
+* Rapid to deploy: a standalone program to run; all configuration are specified in command line with very few options.
+
+
+### Installation
+
+    # Install required development components
+    sudo apt-get install build-essential libssl-dev  # for Ubuntu
+      
+    # Compile and install
+    git clone https://github.com/rssnsj/minivtun.git minivtun
+    cd minivtun/src
+    make
+    make install
+
+### Usage
+
+    Mini virtual tunneller in non-standard protocol.
+    Usage:
+      minivtun [options]
+    Options:
+      -l <ip:port>          IP:port of local binding
+      -r <ip:port>          IP:port of peer device
+      -a <tun_lip/tun_rip>  tunnel IP pair
+      -A <tun_ip6/pfx_len>  tunnel IPv6 address/prefix length pair
+      -m <mtu>              set MTU size, default: 1408.
+      -t <keepalive_timeo>  seconds between sending keep-alive packets, default: 13
+      -n <ifname>           tunnel interface name
+      -p <pid_file>         PID file of the daemon
+      -e <encrypt_key>      shared password for data encryption
+      -N                    turn off encryption for tunnelling data
+      -d                    run as daemon process
+      -h                    print this help
+
+### Examples
+
+Server: Run a VPN server on port 1414, with local virtual address 10.7.0.1, client address space 10.7.0.0/24, encryption password 'Hello':
+
+    /usr/sbin/minivtun -l 0.0.0.0:1414 -a 10.7.0.1/24 -e Hello -d
+
+Client: Connect VPN to the above server (assuming address vpn.abc.com), with local virtual address 10.7.0.33:
+
+    /usr/sbin/minivtun -r vpn.abc.com:1414 -a 10.7.0.33/24 -e Hello -d
+
+Multiple clients on different devices can be connected to the same server:
+
+    /usr/sbin/minivtun -r vpn.abc.com:1414 -a 10.7.0.34/24 -e Hello -d
+    /usr/sbin/minivtun -r vpn.abc.com:1414 -a 10.7.0.35/24 -e Hello -d
+    /usr/sbin/minivtun -r vpn.abc.com:1414 -a 10.7.0.36/24 -e Hello -d
+    ...
+
+### Diagnoses
+
+If you run 'minivtun' server on a VPS (openvz, kvm, docker, ...), I recommend you to enlarge the server side MTU, e.g., 4000. This is because the physical host might enables segmentation offloadings which let your VPS receive large TCP packets (up to 3000 bytes). Since the feature is opened on the physical host, you cannot disable it. So the best way is to change your MTU by adding `-m size`:
+
+    /usr/sbin/minivtun -l 0.0.0.0:1414 -a 10.7.0.1/24 -e Hello -d -m 4000
diff --git a/release/src/router/minivtun/src/Makefile b/release/src/router/minivtun/src/Makefile
new file mode 100644
index 0000000..de71dc5
--- /dev/null
+++ b/release/src/router/minivtun/src/Makefile
@@ -0,0 +1,35 @@
+#
+# Copyright (c) 2015 Justin Liu
+# Author: Justin Liu <rssnsj@gmail.com>
+# https://github.com/rssnsj/minivtun
+#
+
+CC ?= gcc
+CFLAGS += -Wall -O2 $(EXTRACFLAGS)
+HEADERS = minivtun.h library.h list.h jhash.h
+
+ifeq ($(FULL_OPENSSL),y)
+CFLAGS  += -I$(TOP)/openssl/include 
+LDFLAGS += -L$(TOP)/openssl -lssl -lcrypto
+else
+CFLAGS  += -I$(TOP)/cyassl/include -I$(TOP)/cyassl/ctaocrypt/include -DUSE_CYASSL
+#LDFLAGS += $(TOP)/cyassl/src/.libs/libcyassl.a
+LDFLAGS += -L$(TOP)/mssl -lmssl
+endif
+
+
+minivtun: minivtun.o library.o server.o client.o
+	$(CC) -o $@ $^ $(LDFLAGS) 
+
+%.o: %.c $(HEADERS)
+	$(CC) $(CFLAGS) -c -o $@ $<
+
+install: minivtun
+	cp -f minivtun /usr/sbin/
+
+clean:
+	rm -f minivtun *.o
+
+up:
+	rsync ../ root@rssn.cn:minivtun/ -av  --exclude='*.o' --exclude='minivtun'
+
diff --git a/release/src/router/minivtun/src/client.c b/release/src/router/minivtun/src/client.c
new file mode 100644
index 0000000..a677b32
--- /dev/null
+++ b/release/src/router/minivtun/src/client.c
@@ -0,0 +1,297 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include <time.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <sys/uio.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#ifndef ETH_P_IP
+	#include <netinet/ether.h>
+#endif
+#include <linux/if.h>
+#include <linux/if_tun.h>
+
+#include "minivtun.h"
+
+static time_t last_recv = 0, last_keepalive = 0, current_ts = 0;
+static struct sockaddr_in peer_addr;
+
+static int network_receiving(int tunfd, int sockfd)
+{
+	char read_buffer[NM_PI_BUFFER_SIZE], crypt_buffer[NM_PI_BUFFER_SIZE];
+	struct minivtun_msg *nmsg;
+	struct tun_pi pi;
+	void *out_data;
+	size_t ip_dlen, out_dlen;
+	struct sockaddr_in real_peer;
+	socklen_t real_peer_alen;
+	struct iovec iov[2];
+	int rc;
+
+	real_peer_alen = sizeof(real_peer);
+	rc = recvfrom(sockfd, &read_buffer, NM_PI_BUFFER_SIZE, 0,
+			(struct sockaddr *)&real_peer, &real_peer_alen);
+	if (rc <= 0)
+		return 0;
+
+	out_data = crypt_buffer;
+	out_dlen = (size_t)rc;
+	netmsg_to_local(read_buffer, &out_data, &out_dlen);
+	nmsg = out_data;
+
+	if (out_dlen < MINIVTUN_MSG_BASIC_HLEN)
+		return 0;
+ 
+	/* Verify password. */
+	if (memcmp(nmsg->hdr.passwd_md5sum, config.crypto_passwd_md5sum, 16) != 0)
+		return 0;
+
+	last_recv = current_ts;
+
+	switch (nmsg->hdr.opcode) {
+	case MINIVTUN_MSG_KEEPALIVE:
+		break;
+	case MINIVTUN_MSG_IPDATA:
+		if (nmsg->ipdata.proto == htons(ETH_P_IP)) {
+			/* No packet is shorter than a 20-byte IPv4 header. */
+			if (out_dlen < MINIVTUN_MSG_IPDATA_OFFSET + 20)
+				return 0;
+		} else if (nmsg->ipdata.proto == htons(ETH_P_IPV6)) {
+			if (out_dlen < MINIVTUN_MSG_IPDATA_OFFSET + 40)
+				return 0;
+		} else {
+			fprintf(stderr, "*** Invalid protocol: 0x%x.\n", ntohs(nmsg->ipdata.proto));
+			return 0;
+		}
+
+		ip_dlen = ntohs(nmsg->ipdata.ip_dlen);
+		/* Drop incomplete IP packets. */
+		if (out_dlen - MINIVTUN_MSG_IPDATA_OFFSET < ip_dlen)
+			return 0;
+
+		pi.flags = 0;
+		pi.proto = nmsg->ipdata.proto;
+		iov[0].iov_base = &pi;
+		iov[0].iov_len = sizeof(pi);
+		iov[1].iov_base = (char *)nmsg + MINIVTUN_MSG_IPDATA_OFFSET;
+		iov[1].iov_len = ip_dlen;
+		rc = writev(tunfd, iov, 2);
+		break;
+	}
+
+	return 0;
+}
+
+static int tunnel_receiving(int tunfd, int sockfd)
+{
+	char read_buffer[NM_PI_BUFFER_SIZE], crypt_buffer[NM_PI_BUFFER_SIZE];
+	struct tun_pi *pi = (void *)read_buffer;
+	struct minivtun_msg nmsg;
+	void *out_data;
+	size_t ip_dlen, out_dlen;
+	int rc;
+
+	rc = read(tunfd, pi, NM_PI_BUFFER_SIZE);
+	if (rc < sizeof(struct tun_pi))
+		return 0;
+
+	/* We only accept IPv4 or IPv6 frames. */
+	if (pi->proto != htons(ETH_P_IP) && pi->proto != htons(ETH_P_IPV6))
+		return 0;
+
+	ip_dlen = (size_t)rc - sizeof(struct tun_pi);
+
+	if (pi->proto == htons(ETH_P_IP)) {
+		if (ip_dlen < 20)
+			return 0;
+	} else if (pi->proto == htons(ETH_P_IPV6)) {
+		if (ip_dlen < 40)
+			return 0;
+	} else {
+		fprintf(stderr, "*** Invalid protocol: 0x%x.\n", ntohs(pi->proto));
+		return 0;
+	}
+
+	nmsg.hdr.opcode = MINIVTUN_MSG_IPDATA;
+	memset(nmsg.hdr.rsv, 0x0, sizeof(nmsg.hdr.rsv));
+	memcpy(nmsg.hdr.passwd_md5sum, config.crypto_passwd_md5sum,
+		sizeof(nmsg.hdr.passwd_md5sum));
+	nmsg.ipdata.proto = pi->proto;
+	nmsg.ipdata.ip_dlen = htons(ip_dlen);
+	memcpy(nmsg.ipdata.data, pi + 1, ip_dlen);
+
+	/* Do encryption. */
+	out_data = crypt_buffer;
+	out_dlen = MINIVTUN_MSG_IPDATA_OFFSET + ip_dlen;
+	local_to_netmsg(&nmsg, &out_data, &out_dlen);
+
+	rc = sendto(sockfd, out_data, out_dlen, 0,
+		(struct sockaddr *)&peer_addr, sizeof(peer_addr));
+	/**
+	 * NOTICE: Don't update this on each tunnel packet
+	 * transmit. We always need to keep the local virtual IP
+	 * (-a local/...) alive.
+	 */
+	/* last_keepalive = current_ts; */
+
+	return 0;
+}
+
+static int peer_keepalive(int sockfd)
+{
+	char in_data[64], crypt_buffer[64];
+	struct minivtun_msg *nmsg = (struct minivtun_msg *)in_data;
+	void *out_msg;
+	size_t out_len;
+	int rc;
+
+	nmsg->hdr.opcode = MINIVTUN_MSG_KEEPALIVE;
+	memset(nmsg->hdr.rsv, 0x0, sizeof(nmsg->hdr.rsv));
+	memcpy(nmsg->hdr.passwd_md5sum, config.crypto_passwd_md5sum,
+		sizeof(nmsg->hdr.passwd_md5sum));
+	nmsg->keepalive.loc_tun_in = config.local_tun_in;
+	nmsg->keepalive.loc_tun_in6 = config.local_tun_in6;
+
+	out_msg = crypt_buffer;
+	out_len = MINIVTUN_MSG_BASIC_HLEN + sizeof(nmsg->keepalive);
+	local_to_netmsg(nmsg, &out_msg, &out_len);
+
+	rc = sendto(sockfd, out_msg, out_len, 0,
+		(struct sockaddr *)&peer_addr, sizeof(peer_addr));
+
+	/* Update 'last_keepalive' only when it's really sent out. */
+	if (rc > 0) {
+		last_keepalive = current_ts;
+	}
+
+	return rc;
+}
+
+int run_client(int tunfd, const char *peer_addr_pair)
+{
+	struct timeval timeo;
+	int sockfd, rc;
+	fd_set rset;
+	char s_peer_addr[44];
+
+	if ((rc = v4pair_to_sockaddr(peer_addr_pair, ':', &peer_addr)) == 0) {
+		/* DNS resolve OK, start service normally. */
+		last_recv = time(NULL);
+		inet_ntop(peer_addr.sin_family, &peer_addr.sin_addr,
+			s_peer_addr, sizeof(s_peer_addr));
+		printf("Mini virtual tunnelling client to %s:%u, interface: %s.\n",
+			s_peer_addr, ntohs(peer_addr.sin_port), config.devname);
+	} else if (rc == -EAGAIN && config.wait_dns) {
+		/* Resolve later (last_recv = 0). */
+		last_recv = 0;
+		printf("Mini virtual tunnelling client, interface: %s. \n", config.devname);
+		printf("WARNING: DNS resolution of '%s' temporarily unavailable, "
+			"resolving later.\n", peer_addr_pair);
+	} else if (rc == -EINVAL) {
+		fprintf(stderr, "*** Invalid address pair '%s'.\n", peer_addr_pair);
+		return -1;
+	} else {
+		fprintf(stderr, "*** Cannot resolve address pair '%s'.\n", peer_addr_pair);
+		return -1;
+	}
+
+
+	/* The initial tunnelling connection. */
+	if ((sockfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+		fprintf(stderr, "*** socket() failed: %s.\n", strerror(errno));
+		exit(1);
+	}
+	set_nonblock(sockfd);
+
+	/* Run in background. */
+	if (config.in_background)
+		do_daemonize();
+
+	if (config.pid_file) {
+		FILE *fp;
+		if ((fp = fopen(config.pid_file, "w"))) {
+			fprintf(fp, "%d\n", (int)getpid());
+			fclose(fp);
+		}
+	}
+
+	/* For triggering the first keep-alive packet to be sent. */
+	last_keepalive = 0;
+
+	for (;;) {
+		FD_ZERO(&rset);
+		FD_SET(tunfd, &rset);
+		FD_SET(sockfd, &rset);
+
+		timeo.tv_sec = 2;
+		timeo.tv_usec = 0;
+
+		rc = select((tunfd > sockfd ? tunfd : sockfd) + 1, &rset, NULL, NULL, &timeo);
+		if (rc < 0) {
+			fprintf(stderr, "*** select(): %s.\n", strerror(errno));
+			return -1;
+		}
+
+		current_ts = time(NULL);
+		if (last_recv > current_ts)
+			last_recv = current_ts;
+		if (last_keepalive > current_ts)
+			last_keepalive = current_ts;
+
+		/* Packet transmission timed out, send keep-alive packet. */
+		if (current_ts - last_keepalive > config.keepalive_timeo) {
+			peer_keepalive(sockfd);
+		}
+
+		/* Connection timed out, try reconnecting. */
+		if (current_ts - last_recv > config.reconnect_timeo) {
+			while (v4pair_to_sockaddr(peer_addr_pair, ':', &peer_addr) < 0) {
+				fprintf(stderr, "Failed to resolve '%s', retrying.\n",
+					peer_addr_pair);
+				sleep(5);
+			}
+
+			/* Reconnected OK. Reopen the socket for a different local port. */
+			close(sockfd);
+			if ((sockfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+				fprintf(stderr, "*** socket() failed: %s.\n", strerror(errno));
+				exit(1);
+			}
+
+			last_keepalive = 0;
+			last_recv = current_ts;
+
+			inet_ntop(peer_addr.sin_family, &peer_addr.sin_addr,
+				s_peer_addr, sizeof(s_peer_addr));
+			printf("Reconnected to %s:%u.\n", s_peer_addr, ntohs(peer_addr.sin_port));
+			continue;
+		}
+
+		/* No result from select(), do nothing. */
+		if (rc == 0)
+			continue;
+
+		if (FD_ISSET(sockfd, &rset)) {
+			rc = network_receiving(tunfd, sockfd);
+		}
+
+		if (FD_ISSET(tunfd, &rset)) {
+			rc = tunnel_receiving(tunfd, sockfd);
+		}
+	}
+
+	return 0;
+}
+
diff --git a/release/src/router/minivtun/src/jhash.h b/release/src/router/minivtun/src/jhash.h
new file mode 100644
index 0000000..bea1009
--- /dev/null
+++ b/release/src/router/minivtun/src/jhash.h
@@ -0,0 +1,130 @@
+#ifndef _LINUX_JHASH_H
+#define _LINUX_JHASH_H
+
+#include <stdint.h>
+
+/**
+ * rol32 - rotate a 32-bit value left
+ * @word: value to rotate
+ * @shift: bits to roll
+ */
+static inline uint32_t rol32(uint32_t word, unsigned int shift)
+{
+	return (word << shift) | (word >> (32 - shift));
+}
+
+/* jhash.h: Jenkins hash support.
+ *
+ * Copyright (C) 2006. Bob Jenkins (bob_jenkins@burtleburtle.net)
+ *
+ * http://burtleburtle.net/bob/hash/
+ *
+ * These are the credits from Bob's sources:
+ *
+ * lookup3.c, by Bob Jenkins, May 2006, Public Domain.
+ *
+ * These are functions for producing 32-bit hashes for hash table lookup.
+ * hashword(), hashlittle(), hashlittle2(), hashbig(), mix(), and final()
+ * are externally useful functions.  Routines to test the hash are included
+ * if SELF_TEST is defined.  You can use this free for any purpose.  It's in
+ * the public domain.  It has no warranty.
+ *
+ * Copyright (C) 2009-2010 Jozsef Kadlecsik (kadlec@blackhole.kfki.hu)
+ *
+ * I've modified Bob's hash to be useful in the Linux kernel, and
+ * any bugs present are my fault.
+ * Jozsef
+ */
+
+/* Best hash sizes are of power of two */
+#define jhash_size(n)   ((uint32_t)1<<(n))
+/* Mask the hash value, i.e (value & jhash_mask(n)) instead of (value % n) */
+#define jhash_mask(n)   (jhash_size(n)-1)
+
+/* __jhash_mix -- mix 3 32-bit values reversibly. */
+#define __jhash_mix(a, b, c)			\
+{						\
+	a -= c;  a ^= rol32(c, 4);  c += b;	\
+	b -= a;  b ^= rol32(a, 6);  a += c;	\
+	c -= b;  c ^= rol32(b, 8);  b += a;	\
+	a -= c;  a ^= rol32(c, 16); c += b;	\
+	b -= a;  b ^= rol32(a, 19); a += c;	\
+	c -= b;  c ^= rol32(b, 4);  b += a;	\
+}
+
+/* __jhash_final - final mixing of 3 32-bit values (a,b,c) into c */
+#define __jhash_final(a, b, c)			\
+{						\
+	c ^= b; c -= rol32(b, 14);		\
+	a ^= c; a -= rol32(c, 11);		\
+	b ^= a; b -= rol32(a, 25);		\
+	c ^= b; c -= rol32(b, 16);		\
+	a ^= c; a -= rol32(c, 4);		\
+	b ^= a; b -= rol32(a, 14);		\
+	c ^= b; c -= rol32(b, 24);		\
+}
+
+/* An arbitrary initial parameter */
+#define JHASH_INITVAL		0xdeadbeef
+
+/* jhash2 - hash an array of uint32_t's
+ * @k: the key which must be an array of uint32_t's
+ * @length: the number of uint32_t's in the key
+ * @initval: the previous hash, or an arbitray value
+ *
+ * Returns the hash value of the key.
+ */
+static inline uint32_t jhash2(const uint32_t *k, uint32_t length, uint32_t initval)
+{
+	uint32_t a, b, c;
+
+	/* Set up the internal state */
+	a = b = c = JHASH_INITVAL + (length<<2) + initval;
+
+	/* Handle most of the key */
+	while (length > 3) {
+		a += k[0];
+		b += k[1];
+		c += k[2];
+		__jhash_mix(a, b, c);
+		length -= 3;
+		k += 3;
+	}
+
+	/* Handle the last 3 uint32_t's: all the case statements fall through */
+	switch (length) {
+	case 3: c += k[2];
+	case 2: b += k[1];
+	case 1: a += k[0];
+		__jhash_final(a, b, c);
+	case 0:	/* Nothing left to add */
+		break;
+	}
+
+	return c;
+}
+
+
+/* jhash_3words - hash exactly 3, 2 or 1 word(s) */
+static inline uint32_t jhash_3words(uint32_t a, uint32_t b, uint32_t c, uint32_t initval)
+{
+	a += JHASH_INITVAL;
+	b += JHASH_INITVAL;
+	c += initval;
+
+	__jhash_final(a, b, c);
+
+	return c;
+}
+
+static inline uint32_t jhash_2words(uint32_t a, uint32_t b, uint32_t initval)
+{
+	return jhash_3words(a, b, 0, initval);
+}
+
+static inline uint32_t jhash_1word(uint32_t a, uint32_t initval)
+{
+	return jhash_3words(a, 0, 0, initval);
+}
+
+#endif /* _LINUX_JHASH_H */
diff --git a/release/src/router/minivtun/src/library.c b/release/src/router/minivtun/src/library.c
new file mode 100644
index 0000000..107b897
--- /dev/null
+++ b/release/src/router/minivtun/src/library.c
@@ -0,0 +1,83 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <arpa/inet.h>
+
+#include "library.h"
+
+int v4pair_to_sockaddr(const char *pair, char sep, struct sockaddr_in *addr)
+{
+	char host[64], *portp;
+	struct addrinfo hints, *result;
+	int rc;
+
+	/* Only getting an INADDR_ANY address. */
+	if (pair == NULL) {
+		addr->sin_family = AF_INET;
+		addr->sin_addr.s_addr = 0;
+		addr->sin_port = 0;
+		return 0;
+	}
+
+	strncpy(host, pair, sizeof(host));
+	host[sizeof(host) - 1] = '\0';
+
+	if (!(portp = strchr(host, sep)))
+		return -EINVAL;
+	*(portp++) = '\0';
+
+	memset(&hints, 0, sizeof(struct addrinfo));
+	hints.ai_family = AF_INET;    /* Allow IPv4 or IPv6 */
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = AI_PASSIVE;  /* For wildcard IP address */
+	hints.ai_protocol = 0;        /* Any protocol */
+	hints.ai_canonname = NULL;
+	hints.ai_addr = NULL;
+	hints.ai_next = NULL;
+	if ((rc = getaddrinfo(host, portp, &hints, &result)))
+		return -EAGAIN;
+
+	/* Get the first resolution. */
+	*addr = *(struct sockaddr_in *)result->ai_addr;
+	freeaddrinfo(result);
+	return 0;
+}
+
+int do_daemonize(void)
+{
+	pid_t pid;
+
+	if ((pid = fork()) < 0) {
+		fprintf(stderr, "*** fork() error: %s.\n", strerror(errno));
+		return -1;
+	} else if (pid > 0) {
+		/* In parent process */
+		exit(0);
+	} else {
+		/* In child process */
+		int fd;
+		setsid();
+		chdir("/tmp");
+		if ((fd = open("/dev/null", O_RDWR)) >= 0) {
+			dup2(fd, 0);
+			dup2(fd, 1);
+			dup2(fd, 2);
+			if (fd > 2)
+				close(fd);
+		}
+	}
+	return 0;
+}
+
+
diff --git a/release/src/router/minivtun/src/library.h b/release/src/router/minivtun/src/library.h
new file mode 100644
index 0000000..9b3643c
--- /dev/null
+++ b/release/src/router/minivtun/src/library.h
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#ifndef __LIBRARY_H
+#define __LIBRARY_H
+
+#include <sys/types.h>
+#include <stddef.h>
+#include <netdb.h>
+#include <fcntl.h>
+#include <netinet/in.h>
+#if USE_CYASSL
+# include <ctc_md5.h>
+# include <ctc_aes.h>
+
+# define MD5_CTX Md5
+# define MD5_Init(ctx) InitMd5(ctx)
+# define MD5_Update(ctx, in, len) Md5Update(ctx, in, len)
+# define MD5_Final(out, ctx) Md5Final(ctx, out)
+
+# define AES_KEY Aes
+#else
+# include <openssl/aes.h>
+# include <openssl/md5.h>
+#endif
+
+#define __be32 uint32_t
+#define __be16 uint16_t
+#define __u8 uint8_t
+
+#define bool char
+#define true 1
+#define false 0
+
+#define container_of(ptr, type, member) ({			\
+	const typeof(((type *)0)->member) * __mptr = (ptr);	\
+	(type *)((char *)__mptr - offsetof(type, member)); })
+
+/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
+
+
+static inline void gen_string_md5sum(void *out, const char *in)
+{
+	MD5_CTX ctx;
+	MD5_Init(&ctx);
+	MD5_Update(&ctx, in, strlen(in));
+	MD5_Final(out, &ctx);
+}
+
+#define AES_IVEC_INITVAL  { 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, \
+		0x78, 0x90, 0xab, 0xcd, 0xef, 0x12, 0x34, 0x56, 0x78, 0x90, }
+
+static inline void gen_encrypt_key(AES_KEY *key, const char *passwd)
+{
+	char md[16];
+	gen_string_md5sum(md, passwd);
+#if USE_CYASSL
+	unsigned char ivec[AES_BLOCK_SIZE] = AES_IVEC_INITVAL;
+	AesSetKey(key, (byte*)md, sizeof(md), ivec, AES_ENCRYPTION);
+#else
+	AES_set_encrypt_key((void *)md, 128, key);
+#endif
+}
+
+static inline void gen_decrypt_key(AES_KEY *key, const char *passwd)
+{
+	char md[16];
+	gen_string_md5sum(md, passwd);
+#if USE_CYASSL
+	unsigned char ivec[AES_BLOCK_SIZE] = AES_IVEC_INITVAL;
+	AesSetKey(key, (byte*)md, sizeof(md), ivec, AES_DECRYPTION);
+#else
+	AES_set_decrypt_key((void *)&md, 128, key);
+#endif
+}
+
+static inline void bytes_encrypt(AES_KEY *key, const void *in, void *out, size_t *dlen)
+{
+	unsigned char ivec[AES_BLOCK_SIZE] = AES_IVEC_INITVAL;
+	size_t remain = *dlen % AES_BLOCK_SIZE;
+	if (remain) {
+		size_t padding = AES_BLOCK_SIZE - remain;
+		memset((char *)in + *dlen, 0x0, padding);
+		*dlen += padding;
+	}
+#if USE_CYASSL
+	AES_KEY enc_key;
+	memcpy(&enc_key, key, sizeof(enc_key));
+	AesCbcEncrypt(&enc_key, out, in, *dlen);
+#else
+	AES_cbc_encrypt(in, out, *dlen, key, (void *)ivec, AES_ENCRYPT);
+#endif
+}
+
+static inline void bytes_decrypt(AES_KEY *key, const void *in, void *out, size_t *dlen)
+{
+	unsigned char ivec[AES_BLOCK_SIZE] = AES_IVEC_INITVAL;
+	size_t remain = *dlen % AES_BLOCK_SIZE;
+	if (remain) {
+		size_t padding = AES_BLOCK_SIZE - remain;
+		memset((char *)in + *dlen, 0x0, padding);
+		*dlen += padding;
+	}
+#if USE_CYASSL
+	AES_KEY dec_key;
+	memcpy(&dec_key, key, sizeof(dec_key));
+	AesCbcDecrypt(&dec_key, out, in, *dlen);
+#else
+	AES_cbc_encrypt(in, out, *dlen, key, (void *)ivec, AES_DECRYPT);
+#endif
+}
+
+/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */
+
+static inline bool is_valid_unicast_in(struct in_addr *in)
+{
+	uint32_t a = ntohl(in->s_addr);
+	return  ((a & 0xff000000) != 0x00000000) &&
+			((a & 0xf0000000) != 0xe0000000);
+}
+
+static inline bool is_valid_unicast_in6(struct in6_addr *in6)
+{
+	uint32_t a0 = ntohl(((__be32 *)in6)[0]);
+	return  ((a0 & 0xff000000) != 0x00000000) &&
+			((a0 & 0xff000000) != 0xff000000);
+}
+
+int v4pair_to_sockaddr(const char *pair, char sep, struct sockaddr_in *addr);
+
+int do_daemonize(void);
+
+static inline int set_nonblock(int sockfd)
+{
+	if (fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFD, 0)|O_NONBLOCK) == -1)
+		return -1;
+	return 0;
+}
+
+static inline void hexdump(void *d, size_t len)
+{
+	unsigned char *s;
+	for (s = d; len; len--, s++)
+		printf("%02x ", (unsigned int)*s);
+	printf("\n");
+}
+
+#endif /* __LIBRARY_H */
+
diff --git a/release/src/router/minivtun/src/list.h b/release/src/router/minivtun/src/list.h
new file mode 100644
index 0000000..bd65846
--- /dev/null
+++ b/release/src/router/minivtun/src/list.h
@@ -0,0 +1,192 @@
+#ifndef __LIST_H
+#define __LIST_H
+
+#include <sys/types.h>
+#include <stddef.h>
+
+/**
+ * container_of - cast a member of a structure out to the containing structure
+ * @ptr:	the pointer to the member.
+ * @type:	the type of the container struct this is embedded in.
+ * @member:	the name of the member within the struct.
+ *
+ */
+#define container_of(ptr, type, member) ({			\
+	const typeof(((type *)0)->member) * __mptr = (ptr);	\
+	(type *)((char *)__mptr - offsetof(type, member)); })
+
+/*
+ * These are non-NULL pointers that will result in page faults
+ * under normal circumstances, used to verify that nobody uses
+ * non-initialized list entries.
+ */
+#define LIST_POISON1  ((void *) 0x00100100)
+#define LIST_POISON2  ((void *) 0x00200200)
+
+/*
+ * Simple doubly linked list implementation.
+ *
+ * Some of the internal functions ("__xxx") are useful when
+ * manipulating whole lists rather than single entries, as
+ * sometimes we already know the next/prev entries and we can
+ * generate better code by using them directly rather than
+ * using the generic single-entry routines.
+ */
+
+struct list_head {
+	struct list_head *next, *prev;
+};
+
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+
+#define LIST_HEAD(name) \
+	struct list_head name = LIST_HEAD_INIT(name)
+
+static inline void INIT_LIST_HEAD(struct list_head *list)
+{
+	list->next = list;
+	list->prev = list;
+}
+
+/* ------------------------------------------------------- */
+static inline void init_list_entry(struct list_head *entry)
+{
+	entry->next = LIST_POISON1;
+	entry->prev = LIST_POISON2;
+}
+static inline int list_entry_orphan(struct list_head *entry)
+{
+	return entry->next == LIST_POISON1;
+}
+/* ------------------------------------------------------- */
+
+/*
+ * Insert a new entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *new,
+			      struct list_head *prev,
+			      struct list_head *next)
+{
+	next->prev = new;
+	new->next = next;
+	new->prev = prev;
+	prev->next = new;
+}
+
+/**
+ * list_add - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a new entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head, head->next);
+}
+
+/**
+ * list_add_tail - add a new entry
+ * @new: new entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a new entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *new, struct list_head *head)
+{
+	__list_add(new, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head * prev, struct list_head * next)
+{
+	next->prev = prev;
+	prev->next = next;
+}
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty() on entry does not return true after this, the entry is
+ * in an undefined state.
+ */
+static inline void list_del(struct list_head *entry)
+{
+	__list_del(entry->prev, entry->next);
+	entry->next = LIST_POISON1;
+	entry->prev = LIST_POISON2;
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(const struct list_head *head)
+{
+	return head->next == head;
+}
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:	the &struct list_head pointer.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+	container_of(ptr, type, member)
+
+/**
+ * list_first_entry - get the first element from a list
+ * @ptr:	the list head to take the element from.
+ * @type:	the type of the struct this is embedded in.
+ * @member:	the name of the list_struct within the struct.
+ *
+ * Note, that list is expected to be not empty.
+ */
+#define list_first_entry(ptr, type, member) \
+	list_entry((ptr)->next, type, member)
+
+/**
+ * list_next_entry - get the next element in list
+ * @pos:	the type * to cursor
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_next_entry(pos, member) \
+	list_entry((pos)->member.next, typeof(*(pos)), member)
+
+/**
+ * list_for_each_entry	-	iterate over list of given type
+ * @pos:	the type * to use as a loop cursor.
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)				\
+	for (pos = list_entry((head)->next, typeof(*pos), member);	\
+	     /*prefetch(pos->member.next),*/ &pos->member != (head); 	\
+	     pos = list_entry(pos->member.next, typeof(*pos), member))
+
+/**
+ * list_for_each_entry_safe - iterate over list of given type safe against removal of list entry
+ * @pos:	the type * to use as a loop cursor.
+ * @n:		another type * to use as temporary storage
+ * @head:	the head for your list.
+ * @member:	the name of the list_struct within the struct.
+ */
+#define list_for_each_entry_safe(pos, n, head, member)			\
+	for (pos = list_first_entry(head, typeof(*pos), member),	\
+		n = list_next_entry(pos, member);			\
+	     &pos->member != (head); 					\
+	     pos = n, n = list_next_entry(n, member))
+
+#endif /* __LIST_H */
diff --git a/release/src/router/minivtun/src/minivtun.c b/release/src/router/minivtun/src/minivtun.c
new file mode 100644
index 0000000..d24df49
--- /dev/null
+++ b/release/src/router/minivtun/src/minivtun.c
@@ -0,0 +1,296 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <getopt.h>
+#include <errno.h>
+#include <time.h>
+#include <signal.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <linux/if.h>
+#include <linux/if_tun.h>
+
+#include "minivtun.h"
+
+struct minivtun_config config = {
+	.keepalive_timeo = 13,
+	.reconnect_timeo = 60,
+	.devname = "",
+	.tun_mtu = 1416,
+	.crypto_passwd = "",
+	.pid_file = NULL,
+	.in_background = false,
+	.wait_dns = false,
+};
+
+static struct option long_opts[] = {
+	{ "local", required_argument, 0, 'l', },
+	{ "remote", required_argument, 0, 'r', },
+	{ "ipv4-addr", required_argument, 0, 'a', },
+	{ "ipv6-addr", required_argument, 0, 'A', },
+	{ "mtu", required_argument, 0, 'm', },
+	{ "keepalive", required_argument, 0, 't', },
+	{ "ifname", required_argument, 0, 'n', },
+	{ "pidfile", required_argument, 0, 'p', },
+	{ "encryption-key", required_argument, 0, 'e', },
+	{ "route", required_argument, 0, 'v', },
+	{ "no-encryption", no_argument, 0, 'N', },
+	{ "daemon", no_argument, 0, 'd', },
+	{ "wait-dns", no_argument, 0, 'w', },
+	{ "help", no_argument, 0, 'h', },
+	{ 0, 0, 0, 0, },
+};
+
+static void print_help(int argc, char *argv[])
+{
+	printf("Mini virtual tunneller in non-standard protocol.\n");
+	printf("Usage:\n");
+	printf("  %s [options]\n", argv[0]);
+	printf("Options:\n");
+	printf("  -l, --local <ip:port>               IP:port for server to listen\n");
+	printf("  -r, --remote <ip:port>              IP:port of server to connect\n");
+	printf("  -a, --ipv4-addr <tun_lip/tun_rip>   pointopoint IPv4 pair of the virtual interface\n");
+	printf("                  <tun_lip/pfx_len>   IPv4 address/prefix length pair\n");
+	printf("  -A, --ipv6-addr <tun_ip6/pfx_len>   IPv6 address/prefix length pair\n");
+	printf("  -m, --mtu <mtu>                     set MTU size, default: %u.\n", config.tun_mtu);
+	printf("  -t, --keepalive <keepalive_timeo>   interval of keep-alive packets, default: %u\n", config.keepalive_timeo);
+	printf("  -n, --ifname <ifname>               virtual interface name\n");
+	printf("  -p, --pidfile <pid_file>            PID file of the daemon\n");
+	printf("  -e, --encryption-key <encrypt_key>  shared password for data encryption\n");
+	printf("  -v, --route <network/prefix=gateway>\n");
+	printf("                                      route a network to a client address, can be multiple\n");
+	printf("  -N, --no-encryption                 turn off encryption for tunnelling data\n");
+	printf("  -w, --wait-dns                      wait for DNS resolve ready after service started.\n");
+	printf("  -d, --daemon                        run as daemon process\n");
+	printf("  -h, --help                          print this help\n");
+}
+
+static int tun_alloc(char *dev)
+{
+	struct ifreq ifr;
+	int fd, err;
+
+	if ((fd = open("/dev/net/tun", O_RDWR)) < 0) {
+		if ((fd = open("/dev/tun", O_RDWR)) < 0)
+			return -1;
+	}
+
+	memset(&ifr, 0, sizeof(ifr));
+	/* Flags: IFF_TUN   - TUN device (no Ethernet headers)
+	 *        IFF_TAP   - TAP device
+	 *
+	 *        IFF_NO_PI - Do not provide packet information
+	 */
+	ifr.ifr_flags = IFF_TUN;
+	if (*dev)
+		strncpy(ifr.ifr_name, dev, IFNAMSIZ);
+
+	if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0){
+		close(fd);
+		return err;
+	}
+	strcpy(dev, ifr.ifr_name);
+	return fd;
+}
+
+static void parse_virtual_route(const char *arg)
+{
+	char expr[80], *net, *pfx, *gw;
+	struct in_addr network, gateway;
+	unsigned prefix = 0;
+
+	strncpy(expr, arg, sizeof(expr));
+	expr[sizeof(expr) - 1] = '\0';
+
+	/* 192.168.0.0/16=10.7.0.1 */
+	net = expr;
+	if ((pfx = strchr(net, '/')) == NULL) {
+		fprintf(stderr, "*** Not a valid route expression '%s'.\n", arg);
+		exit(1);
+	}
+	*(pfx++) = '\0';
+	if ((gw = strchr(pfx, '=')) == NULL) {
+		fprintf(stderr, "*** Not a valid route expression '%s'.\n", arg);
+		exit(1);
+	}
+	*(gw++) = '\0';
+
+	if (!inet_pton(AF_INET, net, &network) ||
+		!inet_pton(AF_INET, gw, &gateway) || sscanf(pfx, "%u", &prefix) != 1) {
+		fprintf(stderr, "*** Not a valid route expression '%s'.\n", arg);
+		exit(1);
+	}
+
+	vt_route_add(&network, prefix, &gateway);
+}
+
+int main(int argc, char *argv[])
+{
+	const char *tun_ip_config = NULL, *tun_ip6_config = NULL;
+	const char *loc_addr_pair = NULL;
+	const char *peer_addr_pair = NULL;
+	char cmd[100];
+	int tunfd, opt;
+
+	while ((opt = getopt_long(argc, argv, "r:l:a:A:m:t:n:p:e:v:Ndwh",
+			long_opts, NULL)) != -1) {
+
+		switch (opt) {
+		case 'l':
+			loc_addr_pair = optarg;
+			break;
+		case 'r':
+			peer_addr_pair = optarg;
+			break;
+		case 'a':
+			tun_ip_config = optarg;
+			break;
+		case 'A':
+			tun_ip6_config = optarg;
+			break;
+		case 'm':
+			config.tun_mtu = (unsigned)strtoul(optarg, NULL, 10);
+			break;
+		case 't':
+			config.keepalive_timeo = (unsigned)strtoul(optarg, NULL, 10);
+			break;
+		case 'n':
+			strncpy(config.devname, optarg, sizeof(config.devname) - 1);
+			config.devname[sizeof(config.devname) - 1] = '\0';
+			break;
+		case 'p':
+			config.pid_file = optarg;
+			break;
+		case 'e':
+			config.crypto_passwd = optarg;
+			break;
+		case 'v':
+			parse_virtual_route(optarg);
+			break;
+		case 'N':
+			config.crypto_passwd = NULL;
+			break;
+		case 'd':
+			config.in_background = true;
+			break;
+		case 'w':
+			config.wait_dns = true;
+			break;
+		case 'h':
+			print_help(argc, argv);
+			exit(0);
+			break;
+		case '?':
+			exit(1);
+		}
+	}
+
+	if (strlen(config.devname) == 0)
+		strcpy(config.devname, "mv%d");
+	if ((tunfd = tun_alloc(config.devname)) < 0) {
+		fprintf(stderr, "*** open_tun() failed: %s.\n", strerror(errno));
+		exit(1);
+	}
+
+	/* Configure IPv4 address for the interface. */
+	if (tun_ip_config) {
+		char s_lip[20], s_rip[20], *sp;
+		struct in_addr vaddr;
+		int na = 0;
+
+		if (!(sp = strchr(tun_ip_config, '/'))) {
+			fprintf(stderr, "*** Invalid IPv4 address pair: %s.\n", tun_ip_config);
+			exit(1);
+		}
+		strncpy(s_lip, tun_ip_config, sp - tun_ip_config);
+		s_lip[sp - tun_ip_config] = '\0';
+		sp++;
+		strncpy(s_rip, sp, sizeof(s_rip));
+		s_rip[sizeof(s_rip) - 1] = '\0';
+
+		if (!inet_pton(AF_INET, s_lip, &vaddr)) {
+			fprintf(stderr, "*** Invalid local IPv4 address: %s.\n", s_lip);
+			exit(1);
+		}
+		config.local_tun_in = vaddr;
+		if (inet_pton(AF_INET, s_rip, &vaddr)) {
+			struct in_addr __network = { .s_addr = 0 };
+			sprintf(cmd, "ifconfig %s %s pointopoint %s", config.devname, s_lip, s_rip);
+			vt_route_add(&__network, 0, &vaddr);
+		} else if (sscanf(s_rip, "%d", &na) == 1 && na > 0 && na < 31 ) {
+			uint32_t mask = ~((1 << (32 - na)) - 1);
+			sprintf(s_rip, "%u.%u.%u.%u", mask >> 24, (mask >> 16) & 0xff,
+					(mask >> 8) & 0xff, mask & 0xff);
+			sprintf(cmd, "ifconfig %s %s netmask %s", config.devname, s_lip, s_rip);
+		} else {
+			fprintf(stderr, "*** Not a legal netmask or prefix length: %s.\n",
+					s_rip);
+			exit(1);
+		}
+		(void)system(cmd);
+	}
+
+	/* Configure IPv6 address if set. */
+	if (tun_ip6_config) {
+		char s_lip[50], s_pfx[20], *sp;
+		struct in6_addr vaddr;
+		int pfx_len = 0;
+
+		if (!(sp = strchr(tun_ip6_config, '/'))) {
+			fprintf(stderr, "*** Invalid IPv6 address pair: %s.\n", tun_ip6_config);
+			exit(1);
+		}
+		strncpy(s_lip, tun_ip6_config, sp - tun_ip6_config);
+		s_lip[sp - tun_ip6_config] = '\0';
+		sp++;
+		strncpy(s_pfx, sp, sizeof(s_pfx));
+		s_pfx[sizeof(s_pfx) - 1] = '\0';
+
+		if (!inet_pton(AF_INET6, s_lip, &vaddr)) {
+			fprintf(stderr, "*** Invalid local IPv6 address: %s.\n", s_lip);
+			exit(1);
+		}
+		config.local_tun_in6 = vaddr;
+		if (!(sscanf(s_pfx, "%d", &pfx_len) == 1 && pfx_len > 0 && pfx_len <= 128)) {
+			fprintf(stderr, "*** Not a legal prefix length: %s.\n", s_pfx);
+			exit(1);
+		}
+
+		sprintf(cmd, "ifconfig %s add %s/%d", config.devname, s_lip, pfx_len);
+		(void)system(cmd);
+	}
+
+	/* Always bring it up with proper MTU size. */
+	sprintf(cmd, "ifconfig %s mtu %u; ifconfig %s up", config.devname, config.tun_mtu, config.devname);
+	(void)system(cmd);
+
+	if (config.crypto_passwd) {
+		gen_encrypt_key(&config.encrypt_key, config.crypto_passwd);
+		gen_decrypt_key(&config.decrypt_key, config.crypto_passwd);
+		gen_string_md5sum(config.crypto_passwd_md5sum, config.crypto_passwd);
+	} else {
+		fprintf(stderr, "*** WARNING: Transmission will not be encrypted.\n");
+	}
+
+	if (loc_addr_pair) {
+		run_server(tunfd, loc_addr_pair);
+	} else if (peer_addr_pair) {
+		run_client(tunfd, peer_addr_pair);
+	} else {
+		fprintf(stderr, "*** No valid local or peer address specified.\n");
+		exit(1);
+	}
+
+	return 0;
+}
+
diff --git a/release/src/router/minivtun/src/minivtun.h b/release/src/router/minivtun/src/minivtun.h
new file mode 100644
index 0000000..9d3dfa3
--- /dev/null
+++ b/release/src/router/minivtun/src/minivtun.h
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#ifndef __MINIVTUN_H
+#define __MINIVTUN_H
+
+#include "library.h"
+
+extern struct minivtun_config config;
+
+struct minivtun_config {
+	unsigned reconnect_timeo;
+	unsigned keepalive_timeo;
+	char devname[40];
+	unsigned tun_mtu;
+	const char *crypto_passwd;
+	const char *pid_file;
+	bool in_background;
+	bool wait_dns;
+
+	AES_KEY encrypt_key;
+	AES_KEY decrypt_key;
+	char crypto_passwd_md5sum[16];
+	struct in_addr local_tun_in;
+	struct in6_addr local_tun_in6;
+};
+
+enum {
+	MINIVTUN_MSG_KEEPALIVE,
+	MINIVTUN_MSG_IPDATA,
+	MINIVTUN_MSG_DISCONNECT,
+};
+
+#define NM_PI_BUFFER_SIZE  (1024 * 8)
+
+struct minivtun_msg {
+	struct {
+		__u8 opcode;
+		__u8 rsv[3];
+		__u8 passwd_md5sum[16];
+	}  __attribute__((packed)) hdr;
+
+	union {
+		struct {
+			__be16 proto;   /* ETH_P_IP or ETH_P_IPV6 */
+			__be16 ip_dlen; /* Total length of IP/IPv6 data */
+			char data[NM_PI_BUFFER_SIZE];
+		} __attribute__((packed)) ipdata;
+		struct {
+			struct in_addr loc_tun_in;
+			struct in6_addr loc_tun_in6;
+		} __attribute__((packed)) keepalive;
+	};
+} __attribute__((packed));
+
+#define MINIVTUN_MSG_BASIC_HLEN (sizeof(((struct minivtun_msg *)0)->hdr))
+#define MINIVTUN_MSG_IPDATA_OFFSET (offsetof(struct minivtun_msg, ipdata.data))
+
+static inline void local_to_netmsg(const void *in, void **out, size_t *dlen)
+{
+	if (config.crypto_passwd) {
+		bytes_encrypt(&config.encrypt_key, in, *out, dlen);
+	} else {
+		*out = (void *)in;
+	}
+}
+static inline void netmsg_to_local(const void *in, void **out, size_t *dlen)
+{
+	if (config.crypto_passwd) {
+		bytes_decrypt(&config.decrypt_key, in, *out, dlen);
+	} else {
+		*out = (void *)in;
+	}
+}
+
+int run_client(int tunfd, const char *peer_addr_pair);
+int run_server(int tunfd, const char *loc_addr_pair);
+int vt_route_add(struct in_addr *network, unsigned prefix, struct in_addr *gateway);
+
+#endif /* __MINIVTUN_H */
+
diff --git a/release/src/router/minivtun/src/server.c b/release/src/router/minivtun/src/server.c
new file mode 100644
index 0000000..582612e
--- /dev/null
+++ b/release/src/router/minivtun/src/server.c
@@ -0,0 +1,713 @@
+/*
+ * Copyright (c) 2015 Justin Liu
+ * Author: Justin Liu <rssnsj@gmail.com>
+ * https://github.com/rssnsj/minivtun
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <unistd.h>
+#include <time.h>
+#include <signal.h>
+#include <assert.h>
+#include <sys/socket.h>
+#include <sys/ioctl.h>
+#include <fcntl.h>
+#include <sys/uio.h>
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#ifndef ETH_P_IP
+	#include <netinet/ether.h>
+#endif
+#include <linux/if.h>
+#include <linux/if_tun.h>
+
+#include "list.h"
+#include "jhash.h"
+#include "minivtun.h"
+
+/* Timestamp for each loop. */
+static time_t current_ts = 0;
+static uint32_t hash_initval = 0;
+
+/**
+ * Pseudo route table for binding client side subnets
+ * to corresponding connected virtual addresses.
+ */
+struct vt_route {
+	struct in_addr network;
+	struct in_addr netmask;
+	struct in_addr gateway;
+};
+#define VIRTUAL_ROUTE_MAX  (32)
+static struct vt_route *vt_routes[VIRTUAL_ROUTE_MAX];
+static unsigned vt_routes_len = 0; 
+
+int vt_route_add(struct in_addr *network, unsigned prefix, struct in_addr *gateway)
+{
+	struct vt_route *rt;
+	uint32_t mask;
+
+	if (prefix == 0) {
+		mask = 0;
+	} else {
+		mask = ~((1U << (32 - prefix)) - 1) & 0xffffffff;
+	}
+
+	if (vt_routes_len >= VIRTUAL_ROUTE_MAX) {
+		fprintf(stderr, "*** Virtual route table is full.\n");
+		return -1;
+	}
+
+	rt = malloc(sizeof(struct vt_route));
+	rt->netmask.s_addr = htonl(mask);
+	rt->network.s_addr = network->s_addr & rt->netmask.s_addr;
+	rt->gateway = *gateway;
+	vt_routes[vt_routes_len++] = rt;
+
+	return 0;
+}
+
+static struct in_addr *vt_route_lookup(const struct in_addr *addr)
+{
+	unsigned i;
+
+	for (i = 0; i < vt_routes_len; i++) {
+		struct vt_route *rt = vt_routes[i];
+		
+		printf("0x%08x,0x%08x,0x%08x\n", addr->s_addr, rt->netmask.s_addr, rt->network.s_addr);
+		if ((addr->s_addr & rt->netmask.s_addr) == rt->network.s_addr)
+			return &rt->gateway;
+	}
+
+	return NULL;
+}
+
+/* -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=- */
+
+struct ra_entry {
+	struct list_head list;
+	struct sockaddr_in real_addr;
+	time_t last_recv;
+	time_t last_xmit;
+	int refs;
+};
+
+/* Hash table for dedicated clients (real addresses). */
+#define RA_SET_HASH_SIZE  (1 << 3)
+#define RA_SET_LIMIT_EACH_WALK  (10)
+static struct list_head ra_set_hbase[RA_SET_HASH_SIZE];
+static unsigned ra_set_len;
+
+static inline uint32_t real_addr_hash(const struct sockaddr_in *in)
+{
+	return jhash_2words(in->sin_family, in->sin_addr.s_addr, hash_initval);
+}
+
+static struct ra_entry *ra_get_or_create(const struct sockaddr_in *in)
+{
+	struct list_head *chain = &ra_set_hbase[
+		real_addr_hash(in) & (RA_SET_HASH_SIZE - 1)];
+	struct ra_entry *re;
+	char s_real_addr[44];
+
+	list_for_each_entry (re, chain, list) {
+		if (re->real_addr.sin_family == in->sin_family &&
+			re->real_addr.sin_addr.s_addr == in->sin_addr.s_addr &&
+			re->real_addr.sin_port == in->sin_port) {
+			re->refs++;
+			return re;
+		}
+	}
+
+	if ((re = malloc(sizeof(*re))) == NULL) {
+		fprintf(stderr, "*** [%s] malloc(): %s.\n", __FUNCTION__,
+				strerror(errno));
+		return NULL;
+	}
+
+	re->real_addr = *in;
+	re->refs = 1;
+	list_add_tail(&re->list, chain);
+	ra_set_len++;
+
+	inet_ntop(re->real_addr.sin_family, &re->real_addr.sin_addr,
+		s_real_addr, sizeof(s_real_addr));
+	printf("New client [%s:%u]\n", s_real_addr, ntohs(re->real_addr.sin_port));
+
+	return re;
+}
+
+static inline void ra_put_no_free(struct ra_entry *re)
+{
+	assert(re->refs > 0);
+	re->refs--;
+}
+
+static inline void ra_entry_release(struct ra_entry *re)
+{
+	char s_real_addr[44];
+
+	assert(re->refs == 0);
+	list_del(&re->list);
+	ra_set_len--;
+
+	inet_ntop(re->real_addr.sin_family, &re->real_addr.sin_addr,
+		s_real_addr, sizeof(s_real_addr));
+	printf("Recycled client [%s:%u]\n", s_real_addr, ntohs(re->real_addr.sin_port));
+
+	free(re);
+}
+
+struct tun_addr {
+	unsigned short af;
+	union {
+		struct in_addr in;
+		struct in6_addr in6;
+	};
+};
+struct tun_client {
+	struct list_head list;
+	struct tun_addr virt_addr;
+	struct ra_entry *ra;
+	time_t last_recv;
+	time_t last_xmit;
+};
+
+/* Hash table of virtual address in tunnel. */
+#define VA_MAP_HASH_SIZE  (1 << 4)
+#define VA_MAP_LIMIT_EACH_WALK  (10)
+static struct list_head va_map_hbase[VA_MAP_HASH_SIZE];
+static unsigned va_map_len;
+
+static inline void init_va_ra_maps(void)
+{
+	int i;
+
+	for (i = 0; i < VA_MAP_HASH_SIZE; i++)
+		INIT_LIST_HEAD(&va_map_hbase[i]);
+	va_map_len = 0;
+
+	for (i = 0; i < RA_SET_HASH_SIZE; i++)
+		INIT_LIST_HEAD(&ra_set_hbase[i]);
+	ra_set_len = 0;
+}
+
+static inline uint32_t tun_addr_hash(const struct tun_addr *addr)
+{
+	if (addr->af == AF_INET) {
+		return jhash_2words(addr->af, addr->in.s_addr, hash_initval);
+	} else if (addr->af == AF_INET6) {
+		uint32_t __h = jhash_3words(addr->af, addr->in6.s6_addr32[0],
+				addr->in6.s6_addr32[1], hash_initval);
+		return jhash_2words(addr->in6.s6_addr32[2],
+				addr->in6.s6_addr32[3], __h);
+	} else {
+		abort();
+		return 0;
+	}
+}
+
+static inline int tun_addr_comp(
+		const struct tun_addr *a1, const struct tun_addr *a2)
+{
+	if (a1->af != a2->af)
+		return 1;
+
+	if (a1->af == AF_INET) {
+		if (a1->in.s_addr == a2->in.s_addr) {
+			return 0;
+		} else {
+			return 1;
+		}
+	} else if (a1->af == AF_INET6) {
+		if (a1->in6.s6_addr32[0] == a2->in6.s6_addr32[0] &&
+			a1->in6.s6_addr32[1] == a2->in6.s6_addr32[1] &&
+			a1->in6.s6_addr32[2] == a2->in6.s6_addr32[2] &&
+			a1->in6.s6_addr32[3] == a2->in6.s6_addr32[3]) {
+			return 0;
+		} else {
+			return 1;
+		}
+	} else {
+		abort();
+		return 0;
+	}
+}
+
+static inline void tun_client_dump(struct tun_client *ce)
+{
+	char s_virt_addr[44] = "", s_real_addr[44] = "";
+
+	inet_ntop(ce->virt_addr.af, &ce->virt_addr.in,
+		s_virt_addr, sizeof(s_virt_addr));
+	inet_ntop(ce->ra->real_addr.sin_family, &ce->ra->real_addr.sin_addr,
+		s_real_addr, sizeof(s_real_addr));
+	printf("[%s] (%s:%u), last_recv: %lu, last_xmit: %lu\n", s_virt_addr,
+		s_real_addr, ntohs(ce->ra->real_addr.sin_port),
+		(unsigned long)ce->last_recv, (unsigned long)ce->last_xmit);
+}
+
+static inline void tun_client_release(struct tun_client *ce)
+{
+	char s_virt_addr[44], s_real_addr[44];
+
+	inet_ntop(ce->virt_addr.af, &ce->virt_addr.in,
+		s_virt_addr, sizeof(s_virt_addr));
+	inet_ntop(ce->ra->real_addr.sin_family, &ce->ra->real_addr.sin_addr,
+		s_real_addr, sizeof(s_real_addr));
+	printf("Recycled virtual address [%s] at [%s:%u].\n", s_virt_addr, s_real_addr,
+		ntohs(ce->ra->real_addr.sin_port));
+
+	ra_put_no_free(ce->ra);
+
+	list_del(&ce->list);
+	va_map_len--;
+
+	free(ce);
+}
+
+static struct tun_client *tun_client_try_get(const struct tun_addr *vaddr)
+{
+	struct list_head *chain = &va_map_hbase[
+		tun_addr_hash(vaddr) & (VA_MAP_HASH_SIZE - 1)];
+	struct tun_client *ce;
+
+	list_for_each_entry (ce, chain, list) {
+		if (tun_addr_comp(&ce->virt_addr, vaddr) == 0)
+			return ce;
+	}
+	return NULL;
+}
+
+static struct tun_client *tun_client_get_or_create(
+		const struct tun_addr *vaddr, const struct sockaddr_in *raddr)
+{
+	struct list_head *chain = &va_map_hbase[
+		tun_addr_hash(vaddr) & (VA_MAP_HASH_SIZE - 1)];
+	struct tun_client *ce, *__ce;
+	char s_virt_addr[44], s_real_addr[44];
+
+	list_for_each_entry_safe (ce, __ce, chain, list) {
+		if (tun_addr_comp(&ce->virt_addr, vaddr) == 0) {
+			if (ce->ra->real_addr.sin_family != raddr->sin_family ||
+				ce->ra->real_addr.sin_addr.s_addr != raddr->sin_addr.s_addr ||
+				ce->ra->real_addr.sin_port != raddr->sin_port) {
+				/* Real address changed, get a new entry for that. */
+				ra_put_no_free(ce->ra);
+				if ((ce->ra = ra_get_or_create(raddr)) == NULL) {
+					tun_client_release(ce);
+					return NULL;
+				}
+			}
+			return ce;
+		}
+	}
+
+	/* Not found, always create new entry. */
+	if ((ce = malloc(sizeof(*ce))) == NULL) {
+		fprintf(stderr, "*** [%s] malloc(): %s.\n", __FUNCTION__,
+				strerror(errno));
+		return NULL;
+	}
+
+	ce->virt_addr = *vaddr;
+
+	/* Get real_addr entry before adding to list. */
+	if ((ce->ra = ra_get_or_create(raddr)) == NULL) {
+		free(ce);
+		return NULL;
+	}
+	list_add_tail(&ce->list, chain);
+	va_map_len++;
+
+	inet_ntop(ce->virt_addr.af, &ce->virt_addr.in,
+		s_virt_addr, sizeof(s_virt_addr));
+	inet_ntop(ce->ra->real_addr.sin_family, &ce->ra->real_addr.sin_addr,
+		s_real_addr, sizeof(s_real_addr));
+	printf("New virtual address [%s] at [%s:%u].\n", s_virt_addr, s_real_addr,
+		ntohs(ce->ra->real_addr.sin_port));
+
+	return ce;
+}
+
+/**
+ * Send keep-alive packet to the corresponding client
+ * with information stored in 're'.
+ */
+static int ra_entry_keepalive(struct ra_entry *re, int sockfd)
+{
+	char in_data[64], crypt_buffer[64];
+	struct minivtun_msg *nmsg = (struct minivtun_msg *)in_data;
+	void *out_msg;
+	size_t out_len;
+	int rc;
+
+	nmsg->hdr.opcode = MINIVTUN_MSG_KEEPALIVE;
+	memset(nmsg->hdr.rsv, 0x0, sizeof(nmsg->hdr.rsv));
+	memcpy(nmsg->hdr.passwd_md5sum, config.crypto_passwd_md5sum,
+		sizeof(nmsg->hdr.passwd_md5sum));
+	nmsg->keepalive.loc_tun_in = config.local_tun_in;
+	nmsg->keepalive.loc_tun_in6 = config.local_tun_in6;
+
+	out_msg = crypt_buffer;
+	out_len = MINIVTUN_MSG_BASIC_HLEN + sizeof(nmsg->keepalive);
+	local_to_netmsg(nmsg, &out_msg, &out_len);
+
+	rc = sendto(sockfd, out_msg, out_len, 0,
+		(struct sockaddr *)&re->real_addr, sizeof(re->real_addr));
+
+	/* Update 'last_xmit' only when it's really sent out. */
+	if (rc > 0) {
+		re->last_xmit = current_ts;
+	}
+
+	return rc;
+}
+
+static void va_ra_walk_continue(int sockfd)
+{
+	static unsigned va_index = 0, ra_index = 0;
+	unsigned va_walk_max = VA_MAP_LIMIT_EACH_WALK, va_count = 0;
+	unsigned ra_walk_max = RA_SET_LIMIT_EACH_WALK, ra_count = 0;
+	unsigned __va_index = va_index, __ra_index = ra_index;
+	struct tun_client *ce, *__ce;
+	struct ra_entry *re, *__re;
+
+	if (va_walk_max > va_map_len)
+		va_walk_max = va_map_len;
+	if (ra_walk_max > ra_set_len)
+		ra_walk_max = ra_set_len;
+
+	/* Recycle timeout virtual address entries. */
+	if (va_walk_max > 0) {
+		do {
+			list_for_each_entry_safe (ce, __ce, &va_map_hbase[va_index], list) {
+				//tun_client_dump(ce);
+				if (current_ts - ce->last_recv > config.reconnect_timeo) {
+					tun_client_release(ce);
+				}
+				va_count++;
+			}
+			va_index = (va_index + 1) & (VA_MAP_HASH_SIZE - 1);
+		} while (va_count < va_walk_max && va_index != __va_index);
+	}
+
+	/* Recycle or keep-alive real client addresses. */
+	if (ra_walk_max > 0) {
+		do {
+			list_for_each_entry_safe (re, __re, &ra_set_hbase[ra_index], list) {
+				if (current_ts - re->last_recv > config.reconnect_timeo) {
+					if (re->refs == 0) {
+						ra_entry_release(re);
+					}
+				} else if (current_ts - re->last_xmit > config.keepalive_timeo) {
+					ra_entry_keepalive(re, sockfd);
+				}
+				ra_count++;
+			}
+			ra_index = (ra_index + 1) & (RA_SET_HASH_SIZE - 1);
+		} while (ra_count < ra_walk_max && ra_index != __ra_index);
+	}
+
+	printf("Online clients: %u, addresses: %u\n", ra_set_len, va_map_len);
+}
+
+static inline void source_addr_of_ipdata(
+		const void *data, unsigned char af, struct tun_addr *addr)
+{
+	addr->af = af;
+	switch (af) {
+	case AF_INET:
+		memcpy(&addr->in, (char *)data + 12, 4);
+		break;
+	case AF_INET6:
+		memcpy(&addr->in6, (char *)data + 8, 16);
+		break;
+	default:
+		abort();
+	}
+}
+
+static inline void dest_addr_of_ipdata(
+		const void *data, unsigned char af, struct tun_addr *addr)
+{
+	addr->af = af;
+	switch (af) {
+	case AF_INET:
+		memcpy(&addr->in, (char *)data + 16, 4);
+		break;
+	case AF_INET6:
+		memcpy(&addr->in6, (char *)data + 24, 16);
+		break;
+	default:
+		abort();
+	}
+}
+
+
+static int network_receiving(int tunfd, int sockfd)
+{
+	char read_buffer[NM_PI_BUFFER_SIZE], crypt_buffer[NM_PI_BUFFER_SIZE];
+	struct minivtun_msg *nmsg;
+	struct tun_pi pi;
+	void *out_data;
+	size_t ip_dlen, out_dlen;
+	unsigned short af = 0;
+	struct tun_addr virt_addr;
+	struct tun_client *ce;
+	struct ra_entry *re;
+	struct sockaddr_in real_peer;
+	socklen_t real_peer_alen;
+	struct iovec iov[2];
+	int rc;
+
+	real_peer_alen = sizeof(real_peer);
+	rc = recvfrom(sockfd, &read_buffer, NM_PI_BUFFER_SIZE, 0,
+			(struct sockaddr *)&real_peer, &real_peer_alen);
+	if (rc <= 0)
+		return 0;
+
+	out_data = crypt_buffer;
+	out_dlen = (size_t)rc;
+	netmsg_to_local(read_buffer, &out_data, &out_dlen);
+	nmsg = out_data;
+
+	if (out_dlen < MINIVTUN_MSG_BASIC_HLEN)
+		return 0;
+ 
+	/* Verify password. */
+	if (memcmp(nmsg->hdr.passwd_md5sum, config.crypto_passwd_md5sum, 16) != 0)
+		return 0;
+
+	switch (nmsg->hdr.opcode) {
+	case MINIVTUN_MSG_KEEPALIVE:
+		if ((re = ra_get_or_create(&real_peer))) {
+			re->last_recv = current_ts;
+			ra_put_no_free(re);
+		}
+		if (out_dlen < MINIVTUN_MSG_BASIC_HLEN + sizeof(nmsg->keepalive))
+			return 0;
+		if (is_valid_unicast_in(&nmsg->keepalive.loc_tun_in)) {
+			virt_addr.af = AF_INET;
+			virt_addr.in = nmsg->keepalive.loc_tun_in;
+			if ((ce = tun_client_get_or_create(&virt_addr, &real_peer)))
+				ce->last_recv = current_ts;
+		}
+		if (is_valid_unicast_in6(&nmsg->keepalive.loc_tun_in6)) {
+			virt_addr.af = AF_INET6;
+			virt_addr.in6 = nmsg->keepalive.loc_tun_in6;
+			if ((ce = tun_client_get_or_create(&virt_addr, &real_peer)))
+				ce->last_recv = current_ts;
+		}
+		break;
+	case MINIVTUN_MSG_IPDATA:
+		if (nmsg->ipdata.proto == htons(ETH_P_IP)) {
+			af = AF_INET;
+			/* No packet is shorter than a 20-byte IPv4 header. */
+			if (out_dlen < MINIVTUN_MSG_IPDATA_OFFSET + 20)
+				return 0;
+		} else if (nmsg->ipdata.proto == htons(ETH_P_IPV6)) {
+			af = AF_INET6;
+			if (out_dlen < MINIVTUN_MSG_IPDATA_OFFSET + 40)
+				return 0;
+		} else {
+			fprintf(stderr, "*** Invalid protocol: 0x%x.\n", ntohs(nmsg->ipdata.proto));
+			return 0;
+		}
+
+		ip_dlen = ntohs(nmsg->ipdata.ip_dlen);
+		/* Drop incomplete IP packets. */
+		if (out_dlen - MINIVTUN_MSG_IPDATA_OFFSET < ip_dlen)
+			return 0;
+
+		source_addr_of_ipdata(nmsg->ipdata.data, af, &virt_addr);
+		if ((ce = tun_client_get_or_create(&virt_addr, &real_peer)) == NULL)
+			return 0;
+
+		ce->last_recv = current_ts;
+		ce->ra->last_recv = current_ts;
+
+		pi.flags = 0;
+		pi.proto = nmsg->ipdata.proto;
+		iov[0].iov_base = &pi;
+		iov[0].iov_len = sizeof(pi);
+		iov[1].iov_base = (char *)nmsg + MINIVTUN_MSG_IPDATA_OFFSET;
+		iov[1].iov_len = ip_dlen;
+		rc = writev(tunfd, iov, 2);
+		break;
+	}
+
+	return 0;
+}
+
+static int tunnel_receiving(int tunfd, int sockfd)
+{
+	char read_buffer[NM_PI_BUFFER_SIZE], crypt_buffer[NM_PI_BUFFER_SIZE];
+	struct tun_pi *pi = (void *)read_buffer;
+	struct minivtun_msg nmsg;
+	void *out_data;
+	size_t ip_dlen, out_dlen;
+	unsigned short af = 0;
+	struct tun_addr virt_addr;
+	struct tun_client *ce;
+	int rc;
+
+	rc = read(tunfd, pi, NM_PI_BUFFER_SIZE);
+	if (rc < sizeof(struct tun_pi))
+		return 0;
+
+	/* We only accept IPv4 or IPv6 frames. */
+	if (pi->proto != htons(ETH_P_IP) && pi->proto != htons(ETH_P_IPV6))
+		return 0;
+
+	ip_dlen = (size_t)rc - sizeof(struct tun_pi);
+
+	if (pi->proto == htons(ETH_P_IP)) {
+		af = AF_INET;
+		if (ip_dlen < 20)
+			return 0;
+	} else if (pi->proto == htons(ETH_P_IPV6)) {
+		af = AF_INET6;
+		if (ip_dlen < 40)
+			return 0;
+	} else {
+		fprintf(stderr, "*** Invalid protocol: 0x%x.\n", ntohs(pi->proto));
+		return 0;
+	}
+
+	dest_addr_of_ipdata(pi + 1, af, &virt_addr);
+
+	if ((ce = tun_client_try_get(&virt_addr)) == NULL) {
+		/**
+		 * Not an existing client address, lookup the pseudo
+		 * route table for a destination to send.
+		 */
+		if (virt_addr.af == AF_INET) {
+			struct in_addr *gw;
+			struct tun_addr __virt_addr;
+
+			/* Lookup the gateway virtual address first. */
+			if ((gw = vt_route_lookup(&virt_addr.in)) == NULL)
+				return 0;
+
+			/* Then get the gateway client entry. */
+			memset(&__virt_addr, 0x0, sizeof(__virt_addr));
+			__virt_addr.af = AF_INET;
+			__virt_addr.in = *gw;
+			if ((ce = tun_client_try_get(&__virt_addr)) == NULL)
+				return 0;
+
+			/* Finally, create the client entry. */
+			if ((ce = tun_client_get_or_create(&virt_addr,
+				&ce->ra->real_addr)) == NULL)
+				return 0;
+		} else {
+			return 0;
+		}
+	}
+
+	nmsg.hdr.opcode = MINIVTUN_MSG_IPDATA;
+	memset(nmsg.hdr.rsv, 0x0, sizeof(nmsg.hdr.rsv));
+	memcpy(nmsg.hdr.passwd_md5sum, config.crypto_passwd_md5sum,
+		sizeof(nmsg.hdr.passwd_md5sum));
+	nmsg.ipdata.proto = pi->proto;
+	nmsg.ipdata.ip_dlen = htons(ip_dlen);
+	memcpy(nmsg.ipdata.data, pi + 1, ip_dlen);
+
+	/* Do encryption. */
+	out_data = crypt_buffer;
+	out_dlen = MINIVTUN_MSG_IPDATA_OFFSET + ip_dlen;
+	local_to_netmsg(&nmsg, &out_data, &out_dlen);
+
+	rc = sendto(sockfd, out_data, out_dlen, 0,
+		(struct sockaddr *)&ce->ra->real_addr, sizeof(ce->ra->real_addr));
+	ce->last_xmit = current_ts;
+	ce->ra->last_xmit = current_ts;
+
+	return 0;
+}
+
+int run_server(int tunfd, const char *loc_addr_pair)
+{
+	struct timeval timeo;
+	int sockfd, rc;
+	struct sockaddr_in loc_addr;
+	fd_set rset;
+	time_t last_walk;
+	char s_loc_addr[44];
+
+	if (v4pair_to_sockaddr(loc_addr_pair, ':', &loc_addr) < 0) {
+		fprintf(stderr, "*** Cannot resolve address pair '%s'.\n", loc_addr_pair);
+		return -1;
+	}
+
+	inet_ntop(loc_addr.sin_family, &loc_addr.sin_addr,
+		s_loc_addr, sizeof(s_loc_addr));
+	printf("Mini virtual tunnelling server on %s:%u, interface: %s.\n",
+		s_loc_addr, ntohs(loc_addr.sin_port), config.devname);
+
+	/* Initialize address map hash table. */
+	init_va_ra_maps();
+	hash_initval = (uint32_t)time(NULL);
+
+	if ((sockfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0) {
+		fprintf(stderr, "*** socket() failed: %s.\n", strerror(errno));
+		exit(1);
+	}
+	if (bind(sockfd, (struct sockaddr *)&loc_addr, sizeof(loc_addr)) < 0) {
+		fprintf(stderr, "*** bind() failed: %s.\n", strerror(errno));
+		exit(1);
+	}
+	set_nonblock(sockfd);
+
+	/* Run in background. */
+	if (config.in_background)
+		do_daemonize();
+	if (config.pid_file) {
+		FILE *fp;
+		if ((fp = fopen(config.pid_file, "w"))) {
+			fprintf(fp, "%d\n", (int)getpid());
+			fclose(fp);
+		}
+	}
+
+	last_walk = time(NULL);
+
+	for (;;) {
+		FD_ZERO(&rset);
+		FD_SET(tunfd, &rset);
+		FD_SET(sockfd, &rset);
+
+		timeo.tv_sec = 2;
+		timeo.tv_usec = 0;
+
+		rc = select((tunfd > sockfd ? tunfd : sockfd) + 1, &rset, NULL, NULL, &timeo);
+		if (rc < 0) {
+			fprintf(stderr, "*** select(): %s.\n", strerror(errno));
+			return -1;
+		}
+
+		current_ts = time(NULL);
+
+		if (rc > 0) {
+			if (FD_ISSET(sockfd, &rset)) {
+				rc = network_receiving(tunfd, sockfd);
+			}
+
+			if (FD_ISSET(tunfd, &rset)) {
+				rc = tunnel_receiving(tunfd, sockfd);
+			}
+		}
+
+		/* Check connection state at each chance. */
+		if (current_ts - last_walk >= 3) {
+			va_ra_walk_continue(sockfd);
+			last_walk = current_ts;
+		}
+	}
+
+	return 0;
+}
diff --git a/release/src/router/rc/Makefile b/release/src/router/rc/Makefile
index 9474799..9028f2d 100644
--- a/release/src/router/rc/Makefile
+++ b/release/src/router/rc/Makefile
@@ -79,6 +79,10 @@ ifeq ($(TCONFIG_TOR),y)
 OBJS += tor.o
 endif
 
+ifeq ($(TCONFIG_MINIVTUN),y)
+OBJS += minivtun.o
+endif
+
 all: rc
 
 rc: $(OBJS)
diff --git a/release/src/router/rc/minivtun.c b/release/src/router/rc/minivtun.c
new file mode 100644
index 0000000..63939d9
--- /dev/null
+++ b/release/src/router/rc/minivtun.c
@@ -0,0 +1,20 @@
+/*
+
+	MINIVTUN CLIENT start/stop and configuration for Tomato
+	by Jesse (c) 2015
+ 
+*/
+#include "rc.h"
+
+//static const char program[] = "/usr/sbin/minivtun";
+//static const char interface[] = "go0";
+
+void start_minivtun(void)
+{
+	xstart("/etc/minivtun.sh", "start");
+}
+
+void stop_minivtun(void)
+{
+	xstart("/etc/minivtun.sh", "stop");
+}
diff --git a/release/src/router/rc/rc.h b/release/src/router/rc/rc.h
index 92bd964..58a3e3c 100644
--- a/release/src/router/rc/rc.h
+++ b/release/src/router/rc/rc.h
@@ -535,6 +535,12 @@ extern void start_nginxfp();
 extern void stop_nginxfp();
 #endif
 
+// minivtun.c
+#ifdef TCONFIG_MINIVTUN
+void start_minivtun(void);
+void stop_minivtun(void);
+#endif
+
 // tomatoanon.c
 extern void start_tomatoanon(); 
 extern void stop_tomatoanon(); 
diff --git a/release/src/router/rc/services.c b/release/src/router/rc/services.c
index a20aaf9..5f8eecc 100644
--- a/release/src/router/rc/services.c
+++ b/release/src/router/rc/services.c
@@ -2932,6 +2932,14 @@ TOP:
  	}
 #endif
 
+#ifdef TCONFIG_MINIVTUN
+	if (strcmp(service, "minivtun") == 0) {
+		if (action & A_STOP) stop_minivtun();
+		if (action & A_START) start_minivtun();
+		goto CLEAR;
+	}
+#endif
+
 CLEAR:
 	if (next) goto TOP;
 
diff --git a/release/src/router/rc/wan.c b/release/src/router/rc/wan.c
index 37c4c51..261c28b 100644
--- a/release/src/router/rc/wan.c
+++ b/release/src/router/rc/wan.c
@@ -1050,6 +1050,11 @@ void start_wan_done(char *wan_ifname)
 		start_pptp_client();
 #endif
 
+#ifdef TCONFIG_MINIVTUN
+	if (wanup && nvram_get_int("minivtun_enable"))
+		start_minivtun();
+#endif
+
 	unlink(wan_connecting);
 
 	new_qoslimit_start(); //!! RAF
diff --git a/release/src/router/rom/rom/etc/minivtun.sh b/release/src/router/rom/rom/etc/minivtun.sh
new file mode 100755
index 0000000..4187ed0
--- /dev/null
+++ b/release/src/router/rom/rom/etc/minivtun.sh
@@ -0,0 +1,63 @@
+#!/bin/sh
+
+PROGRAM="/usr/sbin/minivtun"
+interface="go0"
+pid_file="/var/run/minivtun.pid"
+action="$1"
+wait_time="10"
+
+
+link_ready()
+{
+        local dev=$1
+        local num=$2
+        local i=0
+        while [ $i -lt "$num" ]; do
+                if ip link show $dev >/dev/null 2>&1; then
+                        # link created
+                        return 0
+                else
+                        sleep 1
+                        let i+=1
+                fi
+        done
+
+        # failed
+        return 1
+}
+
+
+passwd=`nvram get minivtun_passwd`
+srvip=`nvram get minivtun_srvip`
+srvport=`nvram get minivtun_srvport`
+vaddr=`nvram get minivtun_vaddr`
+vmask=`nvram get minivtun_vmask`
+
+if test -n "$passwd"; then
+        crypto_mode="-e${passwd}"
+else
+        crypto_mode="-N"
+fi
+
+case $action in
+start)
+        $PROGRAM -d -r "${srvip}:${srvport}" -a "${vaddr}/${vmask}" "$crypto_mode" -n $interface -p "$pid_file"
+        if link_ready $interface $wait_time ; then
+                /usr/sbin/iptables -t nat -A POSTROUTING -o $interface -j MASQUERADE
+                /etc/route_us.sh add $interface
+        else
+        echo "Execute $PROGRAM fail" >&2
+                exit 1
+        fi
+;;
+stop)
+        /usr/sbin/iptables -t nat -D POSTROUTING -o $interface -j MASQUERADE
+        /etc/route_us.sh del $interface
+        kill -9 `cat $pid_file`
+;;
+*)
+        echo "Unkown action: $action" >&2
+        exit 1
+;;
+esac
+
diff --git a/release/src/router/shared/tomato_version b/release/src/router/shared/tomato_version
index db98728..c20487d 100644
--- a/release/src/router/shared/tomato_version
+++ b/release/src/router/shared/tomato_version
@@ -1 +1 @@
-1.28.0000 ND
\ No newline at end of file
+1.28.0001 MIPSR2-20150601 K26 Fir302B_MiniVPN
\ No newline at end of file
diff --git a/release/src/router/zlib/Makefile b/release/src/router/zlib/Makefile
deleted file mode 100644
index 6bba86c..0000000
--- a/release/src/router/zlib/Makefile
+++ /dev/null
@@ -1,5 +0,0 @@
-all:
-	-@echo "Please use ./configure first.  Thank you."
-
-distclean:
-	make -f Makefile.in distclean
diff --git a/release/src/router/zlib/zconf.h b/release/src/router/zlib/zconf.h
deleted file mode 100644
index 9987a77..0000000
--- a/release/src/router/zlib/zconf.h
+++ /dev/null
@@ -1,511 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2013 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-#  define Z_PREFIX_SET
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_bits        z__tr_flush_bits
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  ifndef Z_SOLO
-#    define compress              z_compress
-#    define compress2             z_compress2
-#    define compressBound         z_compressBound
-#  endif
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePending        z_deflatePending
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateResetKeep      z_deflateResetKeep
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  ifndef Z_SOLO
-#    define gz_error              z_gz_error
-#    define gz_intmax             z_gz_intmax
-#    define gz_strwinerror        z_gz_strwinerror
-#    define gzbuffer              z_gzbuffer
-#    define gzclearerr            z_gzclearerr
-#    define gzclose               z_gzclose
-#    define gzclose_r             z_gzclose_r
-#    define gzclose_w             z_gzclose_w
-#    define gzdirect              z_gzdirect
-#    define gzdopen               z_gzdopen
-#    define gzeof                 z_gzeof
-#    define gzerror               z_gzerror
-#    define gzflush               z_gzflush
-#    define gzgetc                z_gzgetc
-#    define gzgetc_               z_gzgetc_
-#    define gzgets                z_gzgets
-#    define gzoffset              z_gzoffset
-#    define gzoffset64            z_gzoffset64
-#    define gzopen                z_gzopen
-#    define gzopen64              z_gzopen64
-#    ifdef _WIN32
-#      define gzopen_w              z_gzopen_w
-#    endif
-#    define gzprintf              z_gzprintf
-#    define gzvprintf             z_gzvprintf
-#    define gzputc                z_gzputc
-#    define gzputs                z_gzputs
-#    define gzread                z_gzread
-#    define gzrewind              z_gzrewind
-#    define gzseek                z_gzseek
-#    define gzseek64              z_gzseek64
-#    define gzsetparams           z_gzsetparams
-#    define gztell                z_gztell
-#    define gztell64              z_gztell64
-#    define gzungetc              z_gzungetc
-#    define gzwrite               z_gzwrite
-#  endif
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateGetDictionary  z_inflateGetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflateResetKeep      z_inflateResetKeep
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  ifndef Z_SOLO
-#    define uncompress            z_uncompress
-#  endif
-#  define zError                z_zError
-#  ifndef Z_SOLO
-#    define zcalloc               z_zcalloc
-#    define zcfree                z_zcfree
-#  endif
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  ifndef Z_SOLO
-#    define gzFile                z_gzFile
-#  endif
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-#if defined(ZLIB_CONST) && !defined(z_const)
-#  define z_const const
-#else
-#  define z_const
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-#ifndef Z_ARG /* function prototypes for stdarg */
-#  if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#    define Z_ARG(args)  args
-#  else
-#    define Z_ARG(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#if !defined(Z_U4) && !defined(Z_SOLO) && defined(STDC)
-#  include <limits.h>
-#  if (UINT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned
-#  elif (ULONG_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned long
-#  elif (USHRT_MAX == 0xffffffffUL)
-#    define Z_U4 unsigned short
-#  endif
-#endif
-
-#ifdef Z_U4
-   typedef Z_U4 z_crc_t;
-#else
-   typedef unsigned long z_crc_t;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef HAVE_STDARG_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_STDARG_H
-#endif
-
-#ifdef STDC
-#  ifndef Z_SOLO
-#    include <sys/types.h>      /* for off_t */
-#  endif
-#endif
-
-#if defined(STDC) || defined(Z_HAVE_STDARG_H)
-#  ifndef Z_SOLO
-#    include <stdarg.h>         /* for va_list */
-#  endif
-#endif
-
-#ifdef _WIN32
-#  ifndef Z_SOLO
-#    include <stddef.h>         /* for wchar_t */
-#  endif
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if defined(_LARGEFILE64_SOURCE) && -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(__WATCOMC__) && !defined(Z_HAVE_UNISTD_H)
-#  define Z_HAVE_UNISTD_H
-#endif
-#ifndef Z_SOLO
-#  if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#    include <unistd.h>         /* for SEEK_*, off_t, and _LFS64_LARGEFILE */
-#    ifdef VMS
-#      include <unixio.h>       /* for off_t */
-#    endif
-#    ifndef z_off_t
-#      define z_off_t off_t
-#    endif
-#  endif
-#endif
-
-#if defined(_LFS64_LARGEFILE) && _LFS64_LARGEFILE-0
-#  define Z_LFS64
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && defined(Z_LFS64)
-#  define Z_LARGE64
-#endif
-
-#if defined(_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS-0 == 64 && defined(Z_LFS64)
-#  define Z_WANT64
-#endif
-
-#if !defined(SEEK_SET) && !defined(Z_SOLO)
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if !defined(_WIN32) && defined(Z_LARGE64)
-#  define z_off64_t off64_t
-#else
-#  if defined(_WIN32) && !defined(__GNUC__) && !defined(Z_SOLO)
-#    define z_off64_t __int64
-#  else
-#    define z_off64_t z_off_t
-#  endif
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
-- 
2.1.2

